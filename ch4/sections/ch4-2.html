<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 4: Elliptic Curves as Pairing Groups (Part 2)</title>
    <style>
        body {
            font-family: 'Georgia', serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.8;
        }
        h1 {
            color: #1a1a1a;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
        }
        h2 {
            color: #2c3e50;
            margin-top: 40px;
        }
        .example {
            background-color: #f8f9fa;
            border-left: 4px solid #007acc;
            padding: 15px 20px;
            margin: 20px 0;
        }
        .example-title {
            font-weight: bold;
            color: #007acc;
        }
        blockquote {
            background-color: #e8f4f8;
            border-left: 4px solid #17a2b8;
            padding: 15px 20px;
            margin: 20px 0;
            font-style: normal;
        }
        .page-marker {
            color: #999;
            font-size: 0.85em;
            text-align: center;
            margin: 30px 0;
            border-top: 1px dashed #ccc;
            padding-top: 10px;
        }
        figure {
            text-align: center;
            margin: 30px 0;
        }
        figcaption {
            font-size: 0.9em;
            color: #666;
            margin-top: 10px;
        }
        .footnote {
            font-size: 0.85em;
            color: #666;
            border-top: 1px solid #ccc;
            margin-top: 40px;
            padding-top: 10px;
        }
        .nav-links {
            display: flex;
            justify-content: space-between;
            margin: 40px 0;
            padding: 20px 0;
            border-top: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
        }
        .nav-links a {
            color: #007acc;
            text-decoration: none;
        }
        .nav-links a:hover {
            text-decoration: underline;
        }
        .type-box {
            border: 2px solid #333;
            padding: 15px;
            margin: 15px 0;
            background-color: #fafafa;
        }
        .type-title {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 10px;
        }
        .figure-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
    </style>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

<div class="nav-links">
    <a href="ch4-1.html">← 上一部分：r-挠群</a>
    <span></span>
</div>

<!-- ==================== Section 4.2 ==================== -->
<h1>4.2 Pairing types</h1>
<h2>4.2 配对类型</h2>

<!-- ==================== PAGE 58 (continued) ==================== -->
<div class="page-marker">— 58 —</div>

<p>As we mentioned before the previous two examples, the interplay between the maps that are available in any given scenario gives rise to different functionalities within a pairing-based protocol. Galbraith et al. [GPS08] were the first to identify that all of the potentially desirable properties in a protocol cannot be achieved simultaneously, and therefore classified pairings into certain <em>types</em>. There are now four pairing types in the literature; Galbraith et al. originally presented three, but a fourth type was added soon after by Shacham [Sha05]. The pairing types essentially arise from observing the (practical) implications of placing $\mathbb{G}_1$ and $\mathbb{G}_2$ in different subgroups of $E[r]$; in fact, it will soon become obvious that it is always best to set $\mathbb{G}_1 = \mathcal{G}_1$, so the four types really are tied to the definition of $\mathbb{G}_2$. The main factors affecting the classification are the ability to hash and/or randomly sample elements of $\mathbb{G}_2$, the existence of an isomorphism $\psi : \mathbb{G}_2 \to \mathbb{G}_1$ which is often required to make security proofs work (see [GPS08]), and (as always) issues concerning storage and efficiency.</p>

<blockquote>
<strong>配对类型的由来</strong>：Galbraith 等人 [GPS08] 首先识别出，协议中所有理想属性无法同时满足，因此将配对分为不同类型。

<p><strong>影响分类的主要因素</strong>：</p>
<ul>
<li>能否哈希/随机采样 $\mathbb{G}_2$ 的元素</li>
<li>是否存在可计算的同构 $\psi : \mathbb{G}_2 \to \mathbb{G}_1$（安全证明常需要）</li>
<li>存储效率</li>
<li>计算效率</li>
</ul>
<p>实际上，总是最好设 $\mathbb{G}_1 = \mathcal{G}_1$（基域子群），所以四种类型主要取决于 $\mathbb{G}_2$ 的选择。</p>
</blockquote>

<p>We follow the notation and descriptions of Chen et al. [CCS07], and describe each pairing type in turn. The illustrations of each type are in Figures 4.7-4.10, where the base-field group $\mathcal{G}_1 = E[r] \cap \text{Ker}(\pi - [1])$ with generator $\mathcal{P}_1$ is always in the top left, whilst the trace-zero subgroup $\mathcal{G}_2 = E[r] \cap \text{Ker}(\pi - [q])$ with generator $\mathcal{P}_2$ is always in the top right. Let $P_1$ be the generator of $\mathbb{G}_1$ and $P_2$ be the generator of $\mathbb{G}_2$. It should be born in mind that the pairing $e(P, Q)$ will only compute non-trivially if $P$ and $Q$ are in different subgroups.</p>

<!-- Type 1 -->
<div class="type-box">
<div class="type-title">Type 1 pairings（第一类配对）</div>
<p>This is the scenario where $E$ is supersingular, meaning we can map out of $\mathcal{G}_1$ with $\phi$. Thus, we set $\mathbb{G}_1 = \mathbb{G}_2 = \mathcal{G}_1$ (with $P_1 = P_2 = \mathcal{P}_1$). When it comes time to compute a pairing $e$ between say $P$ and $Q$, we can use $\phi$ to map $Q$ to $\phi(Q)$ and define $e(P, Q) = \hat{e}(P, \phi(Q))$, where $\hat{e}$ is the Weil or Tate pairing. There are no hashing problems (getting into $E(\mathbb{F}_q)[r]$ requires a simple cofactor multiplication once we have hashed into $E(\mathbb{F}_q)$) and we trivially have an isomorphism $\psi$ from $\mathbb{G}_2$ to $\mathbb{G}_1$. The drawback</p>
</div>

<!-- ==================== PAGE 59 ==================== -->
<div class="page-marker">— 59 —</div>

<div class="type-box">
<p>of Type 1 pairings comes when considering bandwidth and efficiency: as we will see in Chapter 6, the condition that $E$ be supersingular is highly restrictive when it comes to optimising the speed of computing the pairing. See Figure 4.7.</p>
</div>

<blockquote>
<strong>Type 1 配对简述</strong>：
<ul>
<li><strong>条件</strong>：$E$ 是超奇异曲线（有畸变映射 $\phi$）</li>
<li><strong>设置</strong>：$\mathbb{G}_1 = \mathbb{G}_2 = \mathcal{G}_1$</li>
<li><strong>计算</strong>：$e(P, Q) = \hat{e}(P, \phi(Q))$</li>
<li><strong>优点</strong>：哈希容易，$\psi$ 平凡存在</li>
<li><strong>缺点</strong>：超奇异曲线限制了优化空间，效率较低</li>
</ul>
</blockquote>

<h3>Type 1 配对详解</h3>

<p><strong>什么是超奇异曲线？</strong></p>
<p>回顾前面的内容，椭圆曲线 $E$ 称为<em>超奇异</em>（supersingular）当且仅当它的 Frobenius 迹 $t = q + 1 - \#E(\mathbb{F}_q) = 0$。这个特殊条件使得 $E$ 具有一个重要性质：存在<em>畸变映射</em>（distortion map）$\phi : E[r] \to E[r]$，它能将基域子群 $\mathcal{G}_1$ 的点映射到其他 $r$-挠子群。</p>

<blockquote>
<strong>关键洞察</strong>：超奇异曲线的特殊之处在于畸变映射 $\phi$ 的存在。这个映射允许我们从同一个群 $\mathcal{G}_1$ 中选取配对的两个参数，通过 $\phi$ 将它们"分离"到不同子群。
</blockquote>

<p><strong>为什么设 $\mathbb{G}_1 = \mathbb{G}_2 = \mathcal{G}_1$？</strong></p>
<p>在 Type 1 配对中，我们不需要区分两个不同的群。给定 $P, Q \in \mathcal{G}_1$，配对的计算方式为：
$$e(P, Q) = \hat{e}(P, \phi(Q))$$
虽然 $P$ 和 $Q$ 都在 $\mathcal{G}_1$ 中，但 $\phi(Q)$ 被映射到了另一个子群（通常是 $\mathcal{G}_2$），从而满足配对的非退化性要求。</p>

<div class="example">
<p><span class="example-title">Example（Type 1 配对示例）</span> 考虑一个简单的超奇异曲线例子：</p>

<p><strong>设置</strong>：设 $q = 11$，考虑超奇异曲线 $E/\mathbb{F}_{11} : y^2 = x^3 + x$。</p>
<ul>
<li>计算可得 $\#E(\mathbb{F}_{11}) = 12 = 2^2 \cdot 3$</li>
<li>Frobenius 迹：$t = 11 + 1 - 12 = 0$（确认超奇异）</li>
<li>选择 $r = 3$，则嵌入度 $k = 2$（因为 $3 | (11^2 - 1) = 120$ 但 $3 \nmid (11 - 1) = 10$）</li>
</ul>

<p><strong>群的构造</strong>：</p>
<ul>
<li>$\mathcal{G}_1 = E[3] \cap E(\mathbb{F}_{11})$，例如生成元 $P_1 = (2, 7)$（阶为 3）</li>
<li>设 $P = [1]P_1 = (2, 7)$，$Q = [2]P_1 = (5, 2)$（都在 $\mathcal{G}_1$ 中）</li>
</ul>

<p><strong>配对计算</strong>：</p>
<ul>
<li>直接计算 $\hat{e}(P, Q)$ 会退化（因为两者在同一子群）</li>
<li>应用畸变映射 $\phi(Q)$，将 $Q$ 映到扩域中的另一子群</li>
<li>计算 $e(P, Q) = \hat{e}(P, \phi(Q)) \in \mathbb{F}_{11^2}^*$</li>
<li>结果是一个非平凡的第三单位根：$e(P, Q)^3 = 1$ 且 $e(P, Q) \neq 1$</li>
</ul>

<p><strong>双线性验证</strong>：</p>
<p>$$e([2]P_1, [1]P_1) = e(P_1, P_1)^{2 \cdot 1} = e(P_1, P_1)^2$$</p>
<p>$$e([1]P_1, [2]P_1) = e(P_1, P_1)^{1 \cdot 2} = e(P_1, P_1)^2$$</p>
<p>验证了双线性性质。</p>
</div>

<blockquote>
<strong>例子解读</strong>：
<ul>
<li><strong>哈希到群</strong>：要得到 $\mathcal{G}_1$ 中的随机点，只需先哈希到 $E(\mathbb{F}_q)$（容易），然后乘以辅因子 $\#E(\mathbb{F}_q)/r = 12/3 = 4$</li>
<li><strong>同态 $\psi$</strong>：由于 $\mathbb{G}_1 = \mathbb{G}_2$，同态 $\psi : \mathbb{G}_2 \to \mathbb{G}_1$ 就是恒等映射（平凡但有效）</li>
<li><strong>实现简单</strong>：协议设计者无需区分两个不同的群，所有操作都在同一群中</li>
</ul>
</blockquote>

<p><strong>Type 1 配对的优缺点分析</strong></p>

<div class="type-box">
<p><strong>优点</strong>：</p>
<ol>
<li><strong>对称性</strong>：$\mathbb{G}_1 = \mathbb{G}_2$ 使得协议设计更简单，无需区分源群</li>
<li><strong>哈希友好</strong>：只需要哈希到 $E(\mathbb{F}_q)[r]$，通过辅因子乘法即可，无需复杂的扩域哈希</li>
<li><strong>同态存在</strong>：$\psi : \mathbb{G}_2 \to \mathbb{G}_1$ 平凡存在（恒等映射），满足所有安全证明需求</li>
<li><strong>功能完备</strong>：支持所有理论上可能的配对操作，没有功能限制</li>
</ol>

<p><strong>缺点</strong>：</p>
<ol>
<li><strong>效率低下</strong>：超奇异曲线的嵌入度 $k$ 非常受限（通常 $k \in \{2, 3, 4, 6\}$），无法选择更大的 $k$ 来平衡安全性和效率</li>
<li><strong>优化受限</strong>：无法使用普通曲线上的各种优化技术（如高效的曲线族、端态乘法优化等）</li>
<li><strong>带宽浪费</strong>：为了达到相同的安全级别，需要更大的基域 $\mathbb{F}_q$，导致群元素表示更长</li>
<li><strong>现代标准弃用</strong>：在当前的安全级别下，Type 1 配对比 Type 3 慢几个数量级，已基本被淘汰</li>
</ol>
</div>

<blockquote>
<strong>实践建议</strong>：虽然 Type 1 配对在理论上最简洁（"对称配对"），但在实践中：
<ul>
<li>128 位安全级别下，Type 1 配对比 Type 3 配对慢 <strong>10-20 倍</strong></li>
<li>超奇异曲线的选择极为有限，几乎没有优化空间</li>
<li><strong>不推荐</strong>用于新的协议设计，除非协议特别需要对称性且对性能不敏感</li>
</ul>
<p>历史上，Type 1 配对在早期研究中很流行，因为它简化了理论分析。但随着配对密码学的成熟，Type 3 配对已成为工业标准。</p>
</blockquote>

<div class="example">
<p><span class="example-title">具体性能对比</span></p>
<p>在 128 位安全级别下的典型参数：</p>
<table border="1" style="border-collapse: collapse; width: 100%; margin: 10px 0;">
<tr><th>配对类型</th><th>曲线类型</th><th>基域大小</th><th>嵌入度 $k$</th><th>相对速度</th></tr>
<tr><td>Type 1</td><td>超奇异</td><td>$\mathbb{F}_{q}$，$q \approx 2^{512}$</td><td>2</td><td>1×（基准）</td></tr>
<tr><td>Type 3</td><td>BN 曲线</td><td>$\mathbb{F}_{q}$，$q \approx 2^{256}$</td><td>12</td><td>10-20×（更快）</td></tr>
<tr><td>Type 3</td><td>BLS12-381</td><td>$\mathbb{F}_{q}$，$q = 381$ 位</td><td>12</td><td>15-25×（更快）</td></tr>
</table>
<p>可见，Type 1 配对需要更大的基域才能达到相同安全级别，且计算速度显著落后。</p>
</div>

<p><strong>Type 1 配对的历史地位</strong></p>
<p>尽管 Type 1 配对在现代实践中已被淘汰，但它在配对密码学的发展历史中扮演了重要角色：</p>
<ul>
<li><strong>理论简洁</strong>：许多配对协议最初使用 Type 1 配对进行安全分析，因其对称性简化了证明</li>
<li><strong>教学价值</strong>：Type 1 配对帮助初学者理解配对的基本概念，无需立即处理 $\mathbb{G}_1 \neq \mathbb{G}_2$ 的复杂性</li>
<li><strong>理论基准</strong>：许多理论结果仍以 Type 1 配对的形式表述，然后再转化为 Type 3</li>
</ul>

<blockquote>
<strong>总结</strong>：Type 1 配对是"完美但慢"的选择——它提供了最大的功能性和对称性，但在实际应用中效率太低。现代系统应该使用 Type 3 配对，只有在特殊的理论研究或需要极端对称性的场景下才考虑 Type 1。
</blockquote>

<p>The remaining three cases are defined over ordinary elliptic curves, so (as we will again see in Chapter 6) there are no restrictions imposed on the choice of elliptic curve that lead to a loss of efficiency. For all these situations we have $\mathbb{G}_1 = \mathcal{G}_1$ and $P_1 = \mathcal{P}_1$ (where hashing is relatively easy), so we only need to discuss the choices for $\mathbb{G}_2$ and $P_2$.</p>

<!-- Type 2 -->
<div class="type-box">
<div class="type-title">Type 2 pairings（第二类配对）</div>
<p>In this situation we take $\mathbb{G}_2$ to be any of the $r-1$ subgroups in $E[r]$ that is not $\mathcal{G}_1$ or $\mathcal{G}_2$. We have the map $\psi : \mathbb{G}_2 \to \mathbb{G}_1$ as the trace map Tr. We can also use the anti-trace map to move elements from $\mathbb{G}_2$ into $\mathcal{G}_2$ for efficiency purposes. The drawback is that there is no known way of hashing into $\mathbb{G}_2$ specifically, or to generate random elements of $\mathbb{G}_2$. The best we can do here is to specify a generator $P_2 \in \mathbb{G}_2$ and generate elements via scalar multiplications of $P_2$, but this is often undesirable in protocols since we cannot generate random elements without knowing the discrete logarithm with respect to $P_2$. See Figure 4.8.</p>
</div>

<blockquote>
<strong>Type 2 配对简述</strong>：
<ul>
<li><strong>条件</strong>：$E$ 是普通曲线</li>
<li><strong>设置</strong>：$\mathbb{G}_2$ 是 $E[r]$ 中既不是 $\mathcal{G}_1$ 也不是 $\mathcal{G}_2$ 的某个子群</li>
<li><strong>优点</strong>：有 $\psi = \text{Tr} : \mathbb{G}_2 \to \mathbb{G}_1$</li>
<li><strong>缺点</strong>：无法哈希到 $\mathbb{G}_2$，无法生成随机元素</li>
</ul>
</blockquote>

<h3>Type 2 配对详解</h3>

<p><strong>为什么选择"中间"子群？</strong></p>
<p>回顾 $E[r]$ 的结构：它包含 $r+1$ 个循环子群，其中两个特殊的是：</p>
<ul>
<li>$\mathcal{G}_1 = E[r] \cap \text{Ker}(\pi - [1])$（基域子群，Frobenius 特征值为 1）</li>
<li>$\mathcal{G}_2 = E[r] \cap \text{Ker}(\pi - [q])$（迹零子群，Frobenius 特征值为 $q$）</li>
</ul>
<p>剩下的 $r-1$ 个子群都是"混合"的——它们既不完全在基域中，也不是纯粹的迹零。Type 2 配对选择这些中间子群之一作为 $\mathbb{G}_2$。</p>

<blockquote>
<strong>关键洞察</strong>：Type 2 配对利用<em>迹映射</em>（trace map）$\text{Tr} : E[r] \to \mathcal{G}_1$ 作为从 $\mathbb{G}_2$ 到 $\mathbb{G}_1$ 的同态。这在安全证明中很有用，但代价是无法独立采样 $\mathbb{G}_2$ 的元素。
</blockquote>

<p><strong>迹映射和反迹映射</strong></p>
<p>对于普通曲线，我们有两个重要的映射：</p>
<ul>
<li><strong>迹映射</strong>：$\text{Tr}(P) = P + \pi(P) + \pi^2(P) + \cdots + \pi^{k-1}(P)$，将 $E[r]$ 映射到 $\mathcal{G}_1$</li>
<li><strong>反迹映射</strong>：$\text{aTr}(P) = (k-1)P - \text{Tr}(P)$，将 $E[r]$ 映射到 $\mathcal{G}_2$</li>
</ul>
<p>对于 $\mathbb{G}_2$ 中的点，$\text{Tr}$ 提供了到 $\mathcal{G}_1$ 的可计算同态 $\psi$。</p>

<div class="example">
<p><span class="example-title">Example（Type 2 配对示例）</span> 考虑一个普通曲线的例子：</p>

<p><strong>设置</strong>：设 $q = 13$，考虑曲线 $E/\mathbb{F}_{13} : y^2 = x^3 + 3$。</p>
<ul>
<li>计算可得 $\#E(\mathbb{F}_{13}) = 16 = 2^4$</li>
<li>Frobenius 迹：$t = 13 + 1 - 16 = -2 \neq 0$（确认是普通曲线）</li>
<li>选择 $r = 2$，嵌入度 $k = 4$（因为 $2 | (13^4 - 1)$ 但 $2 \nmid (13^i - 1)$ 对 $i < 4$）</li>
</ul>

<p><strong>构造扩域</strong>：</p>
<ul>
<li>$\mathbb{F}_{13^4} = \mathbb{F}_{13}(u)$，其中 $u^4 + 2 = 0$</li>
<li>$E(\mathbb{F}_{13^4})[2]$ 包含 $2 + 1 = 3$ 个循环子群</li>
</ul>

<p><strong>三个子群</strong>：</p>
<ol>
<li>$\mathcal{G}_1 = E[2] \cap E(\mathbb{F}_{13})$，例如点 $(0, y_0)$ 满足 $y_0^2 = 3$，在 $\mathbb{F}_{13}$ 中无解，但可取 $(1, 4) \in \mathcal{G}_1$</li>
<li>$\mathcal{G}_2 = E[2] \cap \text{Ker}(\pi - [13])$，纯迹零子群，点定义在 $\mathbb{F}_{13^4}$</li>
<li>$\mathbb{G}_2 = $ 第三个子群（既不是 $\mathcal{G}_1$ 也不是 $\mathcal{G}_2$）</li>
</ol>

<p><strong>构造 $\mathbb{G}_2$</strong>：</p>
<ul>
<li>选择 $P_2 \in E(\mathbb{F}_{13^4})[2]$ 使得 $P_2 \notin \mathcal{G}_1$ 且 $P_2 \notin \mathcal{G}_2$</li>
<li>例如，可以取 $P_2 = (u^2 + 1, u^3 + 5)$（坐标含有 $u$ 但不是纯迹零）</li>
<li>验证：$\text{Tr}(P_2) \in \mathcal{G}_1$ 且 $\text{Tr}(P_2) \neq \mathcal{O}$（确认 $P_2 \notin \mathcal{G}_2$）</li>
</ul>

<p><strong>配对计算</strong>：</p>
<ul>
<li>选择 $P_1 \in \mathcal{G}_1 = \mathbb{G}_1$，例如 $P_1 = (1, 4)$</li>
<li>计算 $e(P_1, P_2) = \hat{e}(P_1, P_2) \in \mathbb{F}_{13^4}^*$</li>
<li>结果是 2-torsion 元素：$e(P_1, P_2)^2 = 1$ 且 $e(P_1, P_2) \neq 1$</li>
</ul>

<p><strong>使用迹映射</strong>：</p>
<p>安全证明中常需要 $\psi : \mathbb{G}_2 \to \mathbb{G}_1$：
$$\psi(P_2) = \text{Tr}(P_2) = P_2 + \pi(P_2) + \pi^2(P_2) + \pi^3(P_2) \in \mathcal{G}_1$$
这个映射是可高效计算的。</p>
</div>

<blockquote>
<strong>例子解读</strong>：
<ul>
<li><strong>$\mathbb{G}_1$ 容易操作</strong>：点在基域中，哈希和采样都简单</li>
<li><strong>$\mathbb{G}_2$ 难以独立采样</strong>：只能通过 $[s]P_2$ 生成，其中 $s$ 是已知标量</li>
<li><strong>迹映射可用</strong>：$\psi = \text{Tr}$ 提供了从 $\mathbb{G}_2$ 到 $\mathbb{G}_1$ 的有效同态</li>
</ul>
</blockquote>

<p><strong>Type 2 配对的哈希问题</strong></p>
<p>Type 2 配对的核心问题是：<strong>无法将任意数据哈希到 $\mathbb{G}_2$ 的特定子群</strong>。</p>

<div class="type-box">
<p><strong>为什么不能哈希到 $\mathbb{G}_2$？</strong></p>
<ul>
<li>我们可以哈希到 $E(\mathbb{F}_{13^4})[2]$（整个 2-torsion）</li>
<li>但 $E[2]$ 包含 3 个子群，哈希结果可能落入任意一个</li>
<li>没有已知的有效方法"筛选"出落入特定中间子群 $\mathbb{G}_2$ 的点</li>
<li>$\text{Tr}$ 会将所有点映到 $\mathcal{G}_1$，$\text{aTr}$ 会映到 $\mathcal{G}_2$，但没有映射能"定位"到 $\mathbb{G}_2$</li>
</ul>
</blockquote>

<p><strong>协议中的实际做法</strong></p>
<p>在使用 Type 2 配对的协议中，通常采用以下策略：</p>
<ol>
<li><strong>固定生成元</strong>：在系统参数中指定 $P_2 \in \mathbb{G}_2$</li>
<li><strong>标量乘法</strong>：需要 $\mathbb{G}_2$ 中的"随机"元素时，生成随机标量 $s$ 并计算 $[s]P_2$</li>
<li><strong>问题</strong>：生成者知道离散对数 $\log_{P_2}([s]P_2) = s$，在某些协议中这是安全漏洞</li>
</ol>

<div class="example">
<p><span class="example-title">协议受限示例：Boneh-Franklin IBE</span></p>
<p>假设我们要实现身份基加密（IBE）：</p>
<ul>
<li><strong>公钥提取</strong>：用户 ID 需要映射到 $\mathbb{G}_2$ 中的公钥 $Q_{ID}$</li>
<li><strong>Type 1/3 做法</strong>：$Q_{ID} = H(ID)$，直接哈希到群</li>
<li><strong>Type 2 困境</strong>：无法实现 $H : \{0,1\}^* \to \mathbb{G}_2$
  <ul>
  <li>只能由可信中心计算 $Q_{ID} = [s_{ID}]P_2$</li>
  <li>中心知道 $s_{ID}$，可能破坏安全性</li>
  <li>或者需要复杂的多方计算协议来"忘记" $s_{ID}$</li>
  </ul>
</li>
</ul>
<p>这严重限制了 Type 2 配对在某些协议中的应用。</p>
</div>

<p><strong>Type 2 配对的优缺点分析</strong></p>

<div class="type-box">
<p><strong>优点</strong>：</p>
<ol>
<li><strong>普通曲线</strong>：不受超奇异曲线的效率限制，可选择性能更好的曲线族</li>
<li><strong>同态存在</strong>：$\psi = \text{Tr} : \mathbb{G}_2 \to \mathbb{G}_1$ 可高效计算，满足许多安全证明的需求</li>
<li><strong>历史过渡</strong>：在 Type 1 到 Type 3 的演进中扮演了重要角色</li>
</ol>

<p><strong>缺点</strong>：</p>
<ol>
<li><strong>无法哈希到 $\mathbb{G}_2$</strong>：这是最严重的限制，许多协议需要这个功能</li>
<li><strong>无法独立采样</strong>：生成 $\mathbb{G}_2$ 元素必须通过已知生成元的标量倍数</li>
<li><strong>协议受限</strong>：某些协议（如 IBE、部分签名方案）难以或无法实现</li>
<li><strong>比 Type 3 慢</strong>：$\mathbb{G}_2$ 运算仍在扩域中，没有 Type 3 的扭曲曲线优化</li>
</ol>
</div>

<blockquote>
<strong>Type 2 vs Type 3 权衡</strong>：
<ul>
<li><strong>Type 2 有 $\psi$，但不能哈希到 $\mathbb{G}_2$</strong></li>
<li><strong>Type 3 能哈希到 $\mathbb{G}_2$，但没有可计算的 $\psi$</strong></li>
<li>Chatterjee-Menezes [CM09] 论证：实践中 Type 3 总是更好——需要 $\psi$ 的协议很少，而需要哈希的协议很多</li>
<li>现代观点：<strong>Type 2 是 Type 3 的低效实现</strong>，应该避免使用</li>
</ul>
</blockquote>

<p><strong>Type 2 配对的现状</strong></p>
<p>Type 2 配对在现代密码学中几乎不再使用：</p>
<ul>
<li><strong>理论研究</strong>：一些论文仍分析 Type 2 设置，但主要是为了完整性</li>
<li><strong>实际实现</strong>：几乎所有库都只支持 Type 1（向后兼容）和 Type 3（主流）</li>
<li><strong>协议设计</strong>：新协议应该直接针对 Type 3 设计，避开对 $\psi$ 的依赖</li>
</ul>

<blockquote>
<strong>总结</strong>：Type 2 配对试图在 Type 1 和 Type 3 之间找平衡，但两头不讨好——既没有 Type 1 的完整功能性，也没有 Type 3 的高效率。它主要是历史产物，现代系统应该直接跳过 Type 2，使用 Type 3。
</blockquote>

<!-- Type 3 -->
<div class="type-box">
<div class="type-title">Type 3 pairings（第三类配对）</div>
<p>In this scenario we take $\mathbb{G}_2 = \mathcal{G}_2$, the trace zero subgroup. We can now hash into $\mathbb{G}_2$, at the very least by following a cofactor multiplication in $E(\mathbb{F}_{q^k})$ by the anti-trace map $\text{aTr} : E[r] \to \mathcal{G}_2$ (we will soon see that there is a much more efficient way than this). The ironic drawback here is that the only subgroup (besides $\mathcal{G}_1$) that we can hash into is also the only subgroup we can not find a map out of. An isomorphism $\psi : \mathbb{G}_2 \to \mathbb{G}_1$ trivially exists, we just do not have an efficient way to compute it. Thus, security proofs that rely on the existence of such a $\psi$ are no longer applicable, unless the underlying problem(s) remains hard when the adversary is allowed oracle access to $\psi$ [SV07]. See Figure 4.9.</p>
</div>

<blockquote>
<strong>Type 3 配对简述</strong>：
<ul>
<li><strong>条件</strong>：$E$ 是普通曲线</li>
<li><strong>设置</strong>：$\mathbb{G}_2 = \mathcal{G}_2$（迹零子群）</li>
<li><strong>优点</strong>：可以哈希到 $\mathbb{G}_2$（通过反迹映射）</li>
<li><strong>缺点</strong>：没有可高效计算的 $\psi : \mathbb{G}_2 \to \mathbb{G}_1$</li>
</ul>
<p><strong>讽刺之处</strong>：唯一能哈希进去的子群（除了 $\mathcal{G}_1$），也是唯一找不到映射出来的子群！</p>
</blockquote>

<h3>Type 3 配对详解</h3>

<p><strong>为什么选择迹零子群？</strong></p>
<p>迹零子群 $\mathcal{G}_2 = E[r] \cap \text{Ker}(\pi - [q])$ 是 Frobenius 特征值为 $q$ 的特征空间，它有几个关键性质：</p>
<ul>
<li><strong>完全在扩域中</strong>：$\mathcal{G}_2 \cap E(\mathbb{F}_q) = \{\mathcal{O}\}$（与基域无交集）</li>
<li><strong>反迹映射的像</strong>：$\text{aTr}(E[r]) = \mathcal{G}_2$（可以通过反迹映射到达）</li>
<li><strong>扭曲曲线友好</strong>：如前所述，$\mathcal{G}_2$ 可以通过扭曲曲线映射到更小的域</li>
<li><strong>$\psi$ 难以计算</strong>：同构 $\psi : \mathcal{G}_2 \to \mathcal{G}_1$ 存在，但计算需要解离散对数问题</li>
</ul>

<blockquote>
<strong>关键权衡</strong>：Type 3 配对牺牲了可计算的 $\psi$，换取了：
<ul>
<li>可哈希性（通过 $\text{aTr}$，或更好的方法）</li>
<li>扭曲曲线优化（巨大的效率提升）</li>
<li>更大的曲线选择空间</li>
</ul>
实践证明这是非常值得的权衡！
</blockquote>

<p><strong>哈希到 $\mathcal{G}_2$ 的方法</strong></p>
<p>有两种主要方法将数据哈希到 $\mathcal{G}_2$：</p>
<ol>
<li><strong>朴素方法（通过反迹映射）</strong>：
   <ul>
   <li>哈希到 $E(\mathbb{F}_{q^k})$</li>
   <li>乘以辅因子得到 $P \in E[r]$</li>
   <li>计算 $\text{aTr}(P) = (k-1)P - \text{Tr}(P) \in \mathcal{G}_2$</li>
   <li>成本：需要在 $\mathbb{F}_{q^k}$ 中操作</li>
   </ul>
</li>
<li><strong>高效方法（通过扭曲曲线）</strong>：
   <ul>
   <li>哈希到扭曲曲线 $E'(\mathbb{F}_{q^{k/d}})$</li>
   <li>乘以辅因子得到 $P' \in E'[r]$</li>
   <li>使用 $\Psi$ 映射到 $E(\mathbb{F}_{q^k})$：$P = \Psi(P') \in \mathcal{G}_2$</li>
   <li>成本：只需在 $\mathbb{F}_{q^{k/d}}$ 中操作（$d$ 可达 6）</li>
   </ul>
</li>
</ol>

<div class="example">
<p><span class="example-title">Example（Type 3 配对示例）</span> 使用流行的 BN 曲线（Barreto-Naehrig）：</p>

<p><strong>参数选择</strong>：考虑一个小参数的 BN 曲线示例（实际应用中参数会大得多）。</p>
<ul>
<li>选择参数 $u = 2$（BN 曲线由单参数 $u$ 确定）</li>
<li>$q = 36u^4 + 36u^3 + 24u^2 + 6u + 1 = 769$（基域大小）</li>
<li>$r = 36u^4 + 36u^3 + 18u^2 + 6u + 1 = 761$（子群阶，素数）</li>
<li>曲线方程：$E/\mathbb{F}_{769} : y^2 = x^3 + 2$（BN 曲线总是形式 $y^2 = x^3 + b$）</li>
<li>嵌入度：$k = 12$（BN 曲线的嵌入度总是 12）</li>
<li>$\#E(\mathbb{F}_{769}) = 769 + 1 - t = 768 = 761 + 7$（实际参数需验证）</li>
</ul>

<p><strong>两个群的构造</strong>：</p>
<ol>
<li><strong>$\mathbb{G}_1 = \mathcal{G}_1 \subset E(\mathbb{F}_{769})$</strong>：
   <ul>
   <li>基域子群，阶为 $r = 761$</li>
   <li>生成元 $P_1$：取 $E(\mathbb{F}_{769})$ 中任意点 $R$，计算 $P_1 = [h]R$，其中 $h = \#E(\mathbb{F}_q)/r$</li>
   <li>例如：$P_1 = (100, 458) \in E(\mathbb{F}_{769})$（假设，需验证阶为 761）</li>
   </ul>
</li>
<li><strong>$\mathbb{G}_2 = \mathcal{G}_2 \subset E(\mathbb{F}_{769^{12}})$</strong>：
   <ul>
   <li>迹零子群，阶为 $r = 761$</li>
   <li>生成元在 $\mathbb{F}_{769^{12}}$ 中，但可用扭曲曲线优化</li>
   </ul>
</li>
</ol>

<p><strong>使用六次扭曲优化</strong>：</p>
<p>BN 曲线 $y^2 = x^3 + b$ 支持 $d=6$ 的六次扭曲：</p>
<ul>
<li>扭曲曲线：$E'/\mathbb{F}_{769^2} : y'^2 = x'^3 + 2/\omega$，其中 $\omega \in \mathbb{F}_{769^{12}}$ 但 $\omega^6 \in \mathbb{F}_{769^2}$</li>
<li>$\mathbb{G}_2$ 的运算可在 $E'(\mathbb{F}_{769^2})$ 中进行（而非 $\mathbb{F}_{769^{12}}$）</li>
<li><strong>效率提升</strong>：$\mathbb{F}_{769^2}$ 的运算比 $\mathbb{F}_{769^{12}}$ 快约 36 倍！</li>
</ul>

<p><strong>哈希到 $\mathbb{G}_2$</strong>：</p>
<ol>
<li>给定消息 $m$，计算哈希值 $h = H(m) \in \{0,1\}^*$</li>
<li>使用哈希到曲线算法得到 $R' \in E'(\mathbb{F}_{769^2})$</li>
<li>清除辅因子：$P'_2 = [h']R'$，其中 $h' = \#E'(\mathbb{F}_{769^2})/r$</li>
<li>映射到 $E$：$P_2 = \Psi(P'_2) \in \mathcal{G}_2 \subset E(\mathbb{F}_{769^{12}})$</li>
<li>整个过程只需在 $\mathbb{F}_{769^2}$ 中计算！</li>
</ol>

<p><strong>配对计算</strong>：</p>
<ul>
<li>$P_1 \in \mathbb{G}_1$，$P_2 \in \mathbb{G}_2$（来自不同子群）</li>
<li>计算 $e(P_1, P_2) \in \mathbb{G}_T \subset \mathbb{F}_{769^{12}}^*$</li>
<li>$\mathbb{G}_T$ 是 $\mathbb{F}_{769^{12}}^*$ 的阶为 $r = 761$ 的子群</li>
<li>双线性：$e([a]P_1, [b]P_2) = e(P_1, P_2)^{ab}$ 对所有 $a, b \in \mathbb{Z}_r$</li>
</ul>
</div>

<blockquote>
<strong>例子解读</strong>：
<ul>
<li><strong>$\mathbb{G}_1$ 紧凑</strong>：点在 $\mathbb{F}_{769}$ 中，只需约 10 字节表示（实际 BN254 需 32 字节）</li>
<li><strong>$\mathbb{G}_2$ 较大但可优化</strong>：坐标在 $\mathbb{F}_{769^2}$ 中（通过扭曲），需约 20 字节（实际 BN254 需 64 字节）</li>
<li><strong>$\mathbb{G}_T$ 最大</strong>：元素在 $\mathbb{F}_{769^{12}}$ 中，需约 120 字节（实际 BN254 需 384 字节）</li>
<li><strong>可哈希性</strong>：可以独立哈希到 $\mathbb{G}_1$ 和 $\mathbb{G}_2$，支持所有协议需求</li>
</ul>
</blockquote>

<p><strong>$\psi$ 的不可计算性</strong></p>
<p>虽然抽象同构 $\psi : \mathcal{G}_2 \to \mathcal{G}_1$ 必然存在（两者都是 $r$ 阶循环群），但计算它等价于困难问题：</p>

<div class="type-box">
<p><strong>为什么 $\psi$ 难以计算？</strong></p>
<p>给定 $P_2 \in \mathcal{G}_2$，计算 $\psi(P_2) \in \mathcal{G}_1$ 的步骤：</p>
<ol>
<li>设 $P_2 = [s]G_2$，其中 $G_2$ 是 $\mathcal{G}_2$ 的生成元，$s \in \mathbb{Z}_r$ 未知</li>
<li>$\psi(P_2) = [s]\psi(G_2) = [s]G_1$，其中 $G_1 = \psi(G_2) \in \mathcal{G}_1$</li>
<li>计算 $\psi(P_2)$ 需要知道 $s = \log_{G_2}(P_2)$</li>
<li>这是<strong>离散对数问题</strong>（DLP），是困难的！</li>
</ol>
<p>因此，$\psi$ 在"信息论"意义上存在，但在"计算"意义上不可行。</p>
</div>

<blockquote>
<strong>安全含义</strong>：$\psi$ 的不可计算性是一把双刃剑：
<ul>
<li><strong>缺点</strong>：某些安全证明技术（如"自归约"）依赖可计算的 $\psi$，需要修改</li>
<li><strong>优点</strong>：有些协议的安全性<em>正是基于</em> $\psi$ 的不可计算性！例如结构保持签名</li>
<li><strong>实践</strong>：Chatterjee-Menezes [CM09] 证明，几乎所有协议都能在不依赖 $\psi$ 的情况下证明安全</li>
</ul>
</blockquote>

<p><strong>Type 3 配对在实践中的应用</strong></p>

<div class="example">
<p><span class="example-title">真实世界例子：以太坊的 BN254 曲线</span></p>
<p>以太坊使用 Type 3 配对实现 zk-SNARKs（简洁的零知识证明）：</p>
<ul>
<li><strong>曲线</strong>：BN254（也称 alt-bn128），$u = 4965661367192848881$</li>
<li><strong>参数</strong>：
  <ul>
  <li>$q \approx 2^{254}$（254 位素数）</li>
  <li>$r \approx 2^{254}$（254 位素数子群阶）</li>
  <li>$k = 12$（嵌入度）</li>
  </ul>
</li>
<li><strong>群大小</strong>：
  <ul>
  <li>$\mathbb{G}_1$ 点：32 字节（$\mathbb{F}_q$ 坐标）</li>
  <li>$\mathbb{G}_2$ 点：64 字节（$\mathbb{F}_{q^2}$ 坐标，通过扭曲）</li>
  <li>$\mathbb{G}_T$ 元素：384 字节（$\mathbb{F}_{q^{12}}$ 元素）</li>
  </ul>
</li>
<li><strong>操作</strong>：
  <ul>
  <li>EVM 预编译合约支持 $\mathbb{G}_1$ 加法/标量乘</li>
  <li>EVM 支持 $\mathbb{G}_2$ 加法/标量乘</li>
  <li>EVM 支持配对检查 $e(P_1, P_2) \stackrel{?}{=} e(Q_1, Q_2)$</li>
  </ul>
</li>
<li><strong>应用</strong>：Groth16 zk-SNARKs，证明大小仅 128 字节，验证时间约 0.5ms</li>
</ul>
</div>

<div class="example">
<p><span class="example-title">另一个例子：BLS12-381 曲线</span></p>
<p>BLS12-381 是另一条广泛使用的 Type 3 配对友好曲线（Zcash, Ethereum 2.0, Filecoin 等）：</p>
<ul>
<li><strong>曲线族</strong>：BLS（Barreto-Lynn-Scott），$k = 12$</li>
<li><strong>参数</strong>：$q$ 为 381 位素数，$r$ 为 255 位素数</li>
<li><strong>安全级别</strong>：约 128 位（比 BN254 更安全）</li>
<li><strong>优点</strong>：
  <ul>
  <li>六次扭曲：$\mathbb{G}_2$ 运算在 $\mathbb{F}_{q^2}$ 中</li>
  <li>高效的群运算和配对计算</li>
  <li>支持签名聚合（BLS 签名）</li>
  </ul>
</li>
<li><strong>典型性能</strong>（单核）：
  <ul>
  <li>$\mathbb{G}_1$ 标量乘：~0.3ms</li>
  <li>$\mathbb{G}_2$ 标量乘：~0.9ms</li>
  <li>配对计算：~1.5ms</li>
  </ul>
</li>
</ul>
</div>

<p><strong>Type 3 配对的优缺点分析</strong></p>

<div class="type-box">
<p><strong>优点</strong>：</p>
<ol>
<li><strong>最高效率</strong>：通过扭曲曲线，$\mathbb{G}_2$ 运算速度提升 6-36 倍</li>
<li><strong>完全可哈希</strong>：$\mathbb{G}_1$ 和 $\mathbb{G}_2$ 都支持高效哈希，满足所有协议需求</li>
<li><strong>曲线选择丰富</strong>：BN、BLS、KSS 等多个曲线族可选，参数灵活</li>
<li><strong>带宽优化</strong>：相同安全级别下，$\mathbb{G}_1$ 元素比 Type 1 小一半以上</li>
<li><strong>现代标准</strong>：所有主流库（libff, mcl, blst）和区块链都采用 Type 3</li>
<li><strong>扩展性好</strong>：支持批验证、聚合签名等高级功能</li>
</ol>

<p><strong>缺点</strong>：</p>
<ol>
<li><strong>无可计算的 $\psi$</strong>：某些旧的安全证明技术不适用（但实践中影响很小）</li>
<li><strong>非对称性</strong>：$\mathbb{G}_1 \neq \mathbb{G}_2$ 使协议设计稍复杂（需决定哪些元素放哪个群）</li>
<li><strong>$\mathbb{G}_2$ 稍大</strong>：$\mathbb{G}_2$ 元素通常是 $\mathbb{G}_1$ 的 2 倍大小（但仍比 Type 1 的任何群都小）</li>
</ol>
</div>

<blockquote>
<strong>实践共识</strong>：Type 3 配对的"缺点"在实践中几乎不是问题：
<ul>
<li><strong>$\psi$ 问题</strong>：Chatterjee-Menezes 和后续研究表明，所有重要协议都能在没有 $\psi$ 的情况下证明安全，甚至有些协议的安全性依赖于 $\psi$ 的不可计算性</li>
<li><strong>非对称性</strong>：虽然需要决策，但带来了优化空间——可以将频繁操作放在更快的 $\mathbb{G}_1$ 中</li>
<li><strong>大小差异</strong>：在实际应用中，通信成本由 $\mathbb{G}_T$ 或证明大小主导，$\mathbb{G}_1$ vs $\mathbb{G}_2$ 的差异影响较小</li>
</ul>
<p><strong>结论</strong>：Type 3 在几乎所有维度上都优于其他类型，是无争议的最佳选择。</p>
</blockquote>

<p><strong>协议设计指南：如何选择 $\mathbb{G}_1$ vs $\mathbb{G}_2$</strong></p>
<p>在 Type 3 配对中，协议设计者需要决定将哪些元素放在哪个群：</p>

<div class="type-box">
<p><strong>经验法则</strong>：</p>
<ul>
<li><strong>频繁计算的放 $\mathbb{G}_1$</strong>：$\mathbb{G}_1$ 运算约比 $\mathbb{G}_2$ 快 3 倍</li>
<li><strong>公钥放 $\mathbb{G}_2$</strong>：许多签名方案（如 BLS）将公钥放 $\mathbb{G}_2$，签名放 $\mathbb{G}_1$，因为：
  <ul>
  <li>签名操作在 $\mathbb{G}_1$ 中更快</li>
  <li>聚合签名需要多次 $\mathbb{G}_1$ 运算</li>
  <li>公钥生成只做一次，可接受 $\mathbb{G}_2$ 的开销</li>
  </ul>
</li>
<li><strong>证明者的工作放 $\mathbb{G}_1$</strong>：zk-SNARK 中，证明者的计算量大，应在 $\mathbb{G}_1$ 中操作</li>
<li><strong>验证者的工作尽量少</strong>：验证通常涉及配对，配对对两个群都有开销</li>
</ul>

<p><strong>具体例子</strong>：</p>
<ul>
<li><strong>BLS 签名</strong>：$\text{sk} \in \mathbb{Z}_r$，$\text{pk} \in \mathbb{G}_2$，$\sigma \in \mathbb{G}_1$
  <ul>
  <li>签名：$\sigma = [sk] \cdot H(m)$，$H : \{0,1\}^* \to \mathbb{G}_1$（在 $\mathbb{G}_1$ 中快）</li>
  <li>验证：$e(\sigma, G_2) \stackrel{?}{=} e(H(m), \text{pk})$</li>
  <li>聚合：$\sigma_{agg} = \sigma_1 + \cdots + \sigma_n$（$\mathbb{G}_1$ 加法快）</li>
  </ul>
</li>
<li><strong>Groth16 zk-SNARK</strong>：证明 $\pi = (A, B, C)$，其中 $A, C \in \mathbb{G}_1$，$B \in \mathbb{G}_2$
  <ul>
  <li>证明者大部分工作在 $\mathbb{G}_1$（多标量乘法）</li>
  <li>验证：计算配对 $e(A, B) \cdot e(\alpha, \beta) \cdot e(C, \delta) \stackrel{?}{=} 1$</li>
  </ul>
</li>
</ul>
</div>

<p><strong>Type 3 配对的未来</strong></p>
<p>Type 3 配对将继续主导配对密码学：</p>
<ul>
<li><strong>新曲线研究</strong>：寻找更高安全级别、更快速度的曲线（如 BLS48 用于 256 位安全）</li>
<li><strong>硬件加速</strong>：GPU、FPGA、ASIC 实现进一步提速（已有 10-100 倍加速）</li>
<li><strong>新应用</strong>：去中心化身份、可验证计算、隐私保护区块链等</li>
<li><strong>标准化</strong>：IETF、ISO 等正在标准化 Type 3 配对的曲线和协议</li>
</ul>

<blockquote>
<strong>总结</strong>：Type 3 配对是配对密码学的"黄金标准"——它通过牺牲（几乎用不到的）可计算 $\psi$，换取了巨大的效率提升和完整的功能性。现代所有高性能系统都使用 Type 3，它是实践中唯一真正重要的配对类型。
</blockquote>

<!-- Type 4 -->
<div class="type-box">
<div class="type-title">Type 4 pairings（第四类配对）</div>
<p>In this situation we take $\mathbb{G}_2$ to be the whole $r$-torsion $E[r]$, which is a group of order $r^2$. Hashing into $\mathbb{G}_2$ is possible, but not very efficient, however we cannot hash into the particular subgroup generated by any specific $P_2$ (i.e. $\mathbb{G}_2$ is not cyclic). Note that hashing into $E[r]$ will only give an element in $\mathcal{G}_1$ or $\mathcal{G}_2$ (which is undesirable in this case) with negligibly low probability for large $r$. See Figure 4.10.</p>
</div>

<blockquote>
<strong>Type 4 配对</strong>：
<ul>
<li><strong>设置</strong>：$\mathbb{G}_2 = E[r]$（整个 $r$-挠群，阶为 $r^2$）</li>
<li><strong>注意</strong>：$\mathbb{G}_2$ 不是循环群！</li>
<li>可以哈希到 $E[r]$，但落入 $\mathcal{G}_1$ 或 $\mathcal{G}_2$ 的概率可忽略</li>
</ul>
</blockquote>

<div class="figure-grid">
<figure>
  <img src="images/fig4_7.svg" alt="Figure 4.7: Type 1 pairings" style="max-width: 100%;">
  <figcaption>Figure 4.7: Type 1 pairings.</figcaption>
</figure>
<figure>
  <img src="images/fig4_8.svg" alt="Figure 4.8: Type 2 pairings" style="max-width: 100%;">
  <figcaption>Figure 4.8: Type 2 pairings.</figcaption>
</figure>
<figure>
  <img src="images/fig4_9.svg" alt="Figure 4.9: Type 3 pairings" style="max-width: 100%;">
  <figcaption>Figure 4.9: Type 3 pairings.</figcaption>
</figure>
<figure>
  <img src="images/fig4_10.svg" alt="Figure 4.10: Type 4 pairings" style="max-width: 100%;">
  <figcaption>Figure 4.10: Type 4 pairings.</figcaption>
</figure>
</div>

<!-- ==================== PAGE 60 ==================== -->
<div class="page-marker">— 60 —</div>

<p>Prior to these different situations being brought to the attention of the PBC community [GPS08], authors publishing pairing-based protocols were often incorrectly assuming combinations of the associated properties that could not be achieved in practice. The message to designers of pairing-based protocols was that individual attention is required to prescribe the pairing type which best suits any particular pairing instantiation. Whilst some authors have since followed this advice closely, a good example being [CCS07, Tables 1-6], it still seems most common that designers of pairing protocols take the easy way out and assume a Type 1 pairing. This approach is somewhat justified, as it allows cryptographers to avoid getting bogged down in the complex details of pairings whilst still enjoying all their functional properties, but overall it is less than sat-</p>

<!-- ==================== PAGE 61 ==================== -->
<div class="page-marker">— 61 —</div>

<p>isfactory. The reason is that, at current levels of security, a Type 1 pairing is orders of magnitude more costly than say, a Type 3 pairing. Nowadays all of the state-of-the-art implementations of pairings take place on ordinary curves that assume the Type 3 scenario, where the only potential<sup>3</sup> sacrifice is the map $\psi : \mathbb{G}_2 \to \mathbb{G}_1$. Moreover, Chatterjee and Menezes [CM09] paid closer attention to the role of $\psi$ in protocol (proof) designs and essentially argue that there is no known protocol/proof of security that cannot be translated into the Type 3 setting, claiming that Type 2 pairings (which are less efficient but have $\psi$) are merely inefficient implementations of Type 3 pairings. We note that their claim is only based on empirical evidence; they posed a counter-example as an open problem. Nevertheless, the final message of Menezes' related ECC2009 talk is that "protocol designers who are interested in the performance of their protocols should describe and analyse their protocols using Type 3 pairings" [Men09].</p>

<blockquote>
<strong>Type 3 是实践中的最佳选择！</strong>

<p>Chatterjee 和 Menezes [CM09] 论证：</p>
<ul>
<li>没有已知的协议/安全证明不能转化为 Type 3 设置</li>
<li>Type 2 配对只是 Type 3 配对的低效实现</li>
<li>Type 1 配对比 Type 3 慢<strong>数量级</strong></li>
</ul>

<p>Menezes 在 ECC2009 的结论："关心协议性能的设计者应该使用 Type 3 配对来描述和分析他们的协议。"</p>
</blockquote>

<p>For the remainder of this text then, and unless otherwise stated, the reader should assume we are in the Type 3 scenario where $\mathbb{G}_1 = \mathcal{G}_1 = E[r] \cap \text{Ker}(\pi - [1])$ and $\mathbb{G}_2 = \mathcal{G}_2 = E[r] \cap \text{Ker}(\pi - [q])$.</p>

<blockquote>
<strong>本书的默认设定</strong>：除非另有说明，假设 Type 3 配对：
<ul>
<li>$\mathbb{G}_1 = \mathcal{G}_1 = E[r] \cap \text{Ker}(\pi - [1])$（基域子群）</li>
<li>$\mathbb{G}_2 = \mathcal{G}_2 = E[r] \cap \text{Ker}(\pi - [q])$（迹零子群）</li>
</ul>
</blockquote>

<h3>Frobenius 自同态回顾：理解 $\pi$、$\pi - [1]$ 和 $\pi - [q]$</h3>

<p>上面的定义中出现了 $\pi$、$\text{Ker}(\pi - [1])$ 和 $\text{Ker}(\pi - [q])$ 等符号。让我们详细回顾 Frobenius 自同态及其相关概念。</p>

<h4>1. Frobenius 自同态 $\pi$ 的定义</h4>

<p><strong>Frobenius 映射</strong>（Frobenius map）$\pi$ 是有限域上椭圆曲线的一个核心对象，定义为：</p>
$$\pi : E(\overline{\mathbb{F}}_q) \to E(\overline{\mathbb{F}}_q), \quad \pi(x, y) = (x^q, y^q), \quad \pi(\mathcal{O}) = \mathcal{O}$$
<p>其中 $\overline{\mathbb{F}}_q$ 是 $\mathbb{F}_q$ 的代数闭包。</p>

<blockquote>
<strong>直观理解</strong>：
<ul>
<li>在有限域 $\mathbb{F}_{q^k}$ 中，$q$ 次幂运算 $\alpha \mapsto \alpha^q$ 是一个自同构（Frobenius 自同构）</li>
<li>对于椭圆曲线点 $(x, y)$，将坐标分别应用这个自同构就得到 $\pi(x, y) = (x^q, y^q)$</li>
<li>关键性质：如果 $(x, y) \in E(\mathbb{F}_q)$（坐标在基域中），则 $x^q = x$ 且 $y^q = y$，所以 $\pi(x, y) = (x, y)$</li>
</ul>
</blockquote>

<p><strong>Frobenius 的基本性质</strong>：</p>
<ol>
<li><strong>是群同态</strong>：$\pi(P + Q) = \pi(P) + \pi(Q)$ 对所有点 $P, Q$ 成立</li>
<li><strong>是自同态</strong>：$\pi$ 将 $E$ 映射到自身</li>
<li><strong>保持 $r$-挠</strong>：如果 $P \in E[r]$（即 $[r]P = \mathcal{O}$），则 $\pi(P) \in E[r]$</li>
<li><strong>迭代性质</strong>：$\pi^k(x, y) = (x^{q^k}, y^{q^k})$</li>
</ol>

<div class="example">
<p><span class="example-title">Example（Frobenius 作用）</span></p>
<p>考虑 $q = 11$，$E/\mathbb{F}_{11} : y^2 = x^3 + 7$，扩域 $\mathbb{F}_{11^2} = \mathbb{F}_{11}(i)$ 其中 $i^2 = -1$。</p>

<ul>
<li><strong>基域点</strong>：$P = (2, 4) \in E(\mathbb{F}_{11})$
  <ul>
  <li>$\pi(P) = (2^{11}, 4^{11}) = (2, 4) = P$（因为 $\alpha^{11} = \alpha$ 对所有 $\alpha \in \mathbb{F}_{11}$）</li>
  <li>结论：基域点是 $\pi$ 的不动点</li>
  </ul>
</li>
<li><strong>扩域点</strong>：$Q = (3 + i, 5 + 2i) \in E(\mathbb{F}_{11^2})$（假设在曲线上）
  <ul>
  <li>$i^{11} = i^{10} \cdot i = (i^2)^5 \cdot i = (-1)^5 \cdot i = -i$</li>
  <li>$\pi(Q) = ((3+i)^{11}, (5+2i)^{11}) = (3 - i, 5 - 2i) \neq Q$</li>
  <li>$\pi^2(Q) = \pi(\pi(Q)) = (3 + i, 5 + 2i) = Q$</li>
  <li>结论：$Q$ 在 $\pi^2$ 下回到自身，但 $\pi(Q) \neq Q$</li>
  </ul>
</li>
</ul>
</div>

<h4>2. Frobenius 作为线性算子：特征多项式</h4>

<p>在 $r$-挠群 $E[r]$ 上，Frobenius $\pi$ 可以看作一个线性算子。由于 $E[r] \cong \mathbb{Z}_r \times \mathbb{Z}_r$（当 $r \nmid q$ 时），$\pi$ 是一个 $2 \times 2$ 矩阵（在某个基下）。</p>

<p><strong>特征多项式</strong>：$\pi$ 满足 Frobenius 方程
$$\pi^2 - [t]\pi + [q] = 0$$
其中：</p>
<ul>
<li>$t = q + 1 - \#E(\mathbb{F}_q)$ 是 <strong>Frobenius 迹</strong>（trace）</li>
<li>$[n]$ 表示标量乘法映射：$[n](P) = P + P + \cdots + P$（$n$ 次）</li>
<li>方程中的运算是<em>自同态的复合</em></li>
</ul>

<blockquote>
<strong>代数解释</strong>：
<ul>
<li>这类似于矩阵的特征多项式 $\lambda^2 - t\lambda + q = 0$</li>
<li>$\pi$ 的特征值是 $\lambda_{1,2} = \frac{t \pm \sqrt{t^2 - 4q}}{2}$</li>
<li>对于普通曲线（$t \neq 0$），两个特征值是 $1$ 和 $q$（在合适的意义下）</li>
<li>对于超奇异曲线（$t = 0$），$\pi^2 = [q]$</li>
</ul>
</blockquote>

<h4>3. 自同态的减法：$\pi - [1]$ 和 $\pi - [q]$ 的含义</h4>

<p>表达式 $\pi - [1]$ 和 $\pi - [q]$ 中的减号指的是<strong>自同态的减法</strong>。</p>

<p><strong>自同态环</strong>：椭圆曲线的自同态（从 $E$ 到 $E$ 的群同态）构成一个环 $\text{End}(E)$，其中：</p>
<ul>
<li><strong>加法</strong>：$(f + g)(P) = f(P) + g(P)$（输出点的加法）</li>
<li><strong>乘法</strong>：$(f \circ g)(P) = f(g(P))$（复合）</li>
<li><strong>零元</strong>：零映射 $0(P) = \mathcal{O}$ 对所有 $P$</li>
</ul>

<p>因此：</p>
<ul>
<li>$(\pi - [1])(P) = \pi(P) - [1](P) = \pi(P) - P$</li>
<li>$(\pi - [q])(P) = \pi(P) - [q](P) = \pi(P) - [q]P$</li>
</ul>

<div class="example">
<p><span class="example-title">Example（自同态运算）</span></p>
<p>继续上面的例子，$q = 11$，$P = (2, 4) \in E(\mathbb{F}_{11})$，$Q = (3+i, 5+2i) \in E(\mathbb{F}_{11^2})$。</p>

<ul>
<li><strong>对基域点 $P$</strong>：
  $$(\pi - [1])(P) = \pi(P) - P = P - P = \mathcal{O}$$
  所以 $P \in \text{Ker}(\pi - [1])$
</li>
<li><strong>对扩域点 $Q$</strong>：
  $$(\pi - [1])(Q) = \pi(Q) - Q = (3-i, 5-2i) - (3+i, 5+2i) \neq \mathcal{O}$$
  假设这不等于 $\mathcal{O}$（需具体计算），则 $Q \notin \text{Ker}(\pi - [1])$
</li>
</ul>
</div>

<h4>4. 核 $\text{Ker}(\pi - [1])$ 和 $\text{Ker}(\pi - [q])$</h4>

<p><strong>核的定义</strong>：对于自同态 $\phi$，
$$\text{Ker}(\phi) = \{P \in E : \phi(P) = \mathcal{O}\}$$
是被 $\phi$ 映到无穷远点的所有点的集合。</p>

<p><strong>两个重要的核</strong>：</p>

<div class="type-box">
<p><strong>$\text{Ker}(\pi - [1])$：Frobenius 的不动点</strong></p>
$$\text{Ker}(\pi - [1]) = \{P \in E : \pi(P) - P = \mathcal{O}\} = \{P \in E : \pi(P) = P\}$$
<p>这恰好是 $\pi$ 的<strong>不动点集合</strong>，即那些坐标在 Frobenius 下不变的点。</p>

<p><strong>关键事实</strong>：$\text{Ker}(\pi - [1]) = E(\mathbb{F}_q)$</p>
<ul>
<li>如果 $P = (x, y) \in E(\mathbb{F}_q)$，则 $x, y \in \mathbb{F}_q$，所以 $x^q = x$ 且 $y^q = y$，即 $\pi(P) = P$</li>
<li>反之，如果 $\pi(P) = P$，则 $(x^q, y^q) = (x, y)$，所以 $x, y \in \mathbb{F}_q$</li>
</ul>
<p>因此，$E[r] \cap \text{Ker}(\pi - [1]) = E[r] \cap E(\mathbb{F}_q) = \mathcal{G}_1$ 是<strong>基域子群</strong>。</p>
</div>

<div class="type-box">
<p><strong>$\text{Ker}(\pi - [q])$：特征值 $q$ 的特征空间</strong></p>
$$\text{Ker}(\pi - [q]) = \{P \in E : \pi(P) - [q]P = \mathcal{O}\} = \{P \in E : \pi(P) = [q]P\}$$
<p>这是 $\pi$ 的特征值 $q$ 对应的<strong>特征空间</strong>。</p>

<p><strong>关键性质</strong>：</p>
<ul>
<li>由 Frobenius 方程 $\pi^2 - [t]\pi + [q] = 0$，可以导出 $\pi$ 在 $E[r]$ 上的两个特征空间</li>
<li>对于普通曲线，两个特征值是 $1$ 和 $q$（模 $r$ 意义下）</li>
<li>$\text{Ker}(\pi - [q])$ 的元素满足 $\pi(P) = [q]P$</li>
</ul>

<p><strong>迹零性质</strong>：如果 $P \in \text{Ker}(\pi - [q])$，则
$$\text{Tr}(P) = P + \pi(P) + \pi^2(P) + \cdots + \pi^{k-1}(P)$$
在 $r$-挠中等于 $\mathcal{O}$（需要 $k$ 是嵌入度），因此称为<strong>迹零子群</strong>。</p>

<p>因此，$E[r] \cap \text{Ker}(\pi - [q]) = \mathcal{G}_2$ 是<strong>迹零子群</strong>。</p>
</div>

<h4>5. 几何直观：两个特征空间的分解</h4>

<p>在 $r$-挠群 $E[r]$ 上，Frobenius $\pi$ 作为线性算子可以对角化（在合适的基下）：</p>
$$E[r] = \mathcal{G}_1 \oplus \mathcal{G}_2 = \text{Ker}(\pi - [1]) \oplus \text{Ker}(\pi - [q])$$

<blockquote>
<strong>类比线性代数</strong>：
<ul>
<li>$\mathcal{G}_1$ 是特征值 $\lambda_1 = 1$ 的特征空间（$\pi$ 的不动点）</li>
<li>$\mathcal{G}_2$ 是特征值 $\lambda_2 = q$ 的特征空间</li>
<li>$E[r]$ 是这两个特征空间的直和（因为特征值不同）</li>
<li>每个特征空间都是 $r$ 阶循环群</li>
</ul>
</blockquote>

<div class="example">
<p><span class="example-title">Example（完整示例）</span></p>
<p>$q = 13$，$E/\mathbb{F}_{13} : y^2 = x^3 + 3$，$\#E(\mathbb{F}_{13}) = 16$，$r = 2$，$k = 4$。</p>

<p><strong>Frobenius 迹</strong>：$t = 13 + 1 - 16 = -2$</p>

<p><strong>基域子群</strong> $\mathcal{G}_1 = E[2] \cap E(\mathbb{F}_{13})$：</p>
<ul>
<li>寻找 $P = (x, y)$ 满足 $[2]P = \mathcal{O}$ 且 $x, y \in \mathbb{F}_{13}$</li>
<li>这些点满足 $\pi(P) = P$（Frobenius 不动点）</li>
<li>例如：$P_1 = (1, 4) \in \mathcal{G}_1$（假设，需验证）</li>
</ul>

<p><strong>迹零子群</strong> $\mathcal{G}_2 = E[2] \cap \text{Ker}(\pi - [13])$：</p>
<ul>
<li>寻找 $P = (x, y) \in E(\mathbb{F}_{13^4})[2]$ 满足 $\pi(P) = [13]P \equiv [1]P \pmod{2} = P$</li>
<li>等等，这里需要小心：在 $E[2]$ 中，$[13] \equiv [1] \pmod{2}$，所以实际上...
  <ul>
  <li>不对，应该考虑 $\pi$ 作为线性算子在 $\mathbb{Z}_2$ 上的作用</li>
  <li>由于 $13 \equiv 1 \pmod{2}$，特征值实际上都是 $1$ 模 $2$</li>
  <li>这个例子中 $r = 2$ 太小，不太合适</li>
  </ul>
</li>
</ul>

<p><em>（更好的例子应该选择 $r$ 为较大素数且 $q \not\equiv 1 \pmod{r}$）</em></p>
</div>

<h4>6. 为什么这个分解对配对重要？</h4>

<p>配对 $e : E[r] \times E[r] \to \mu_r$ 有一个关键性质：</p>
<blockquote>
<strong>配对的非退化性条件</strong>：如果 $P, Q$ 在 $E[r]$ 的<em>同一个</em>循环子群中，则 $e(P, Q) = 1$（退化）。
</blockquote>

<p>因此，要得到非平凡的配对，必须从<strong>不同的</strong>子群选取参数。$\mathcal{G}_1$ 和 $\mathcal{G}_2$ 的分解正好提供了这样两个自然的、互补的子群：</p>
<ul>
<li>$\mathcal{G}_1$（Frobenius 不动点）在基域中，容易操作</li>
<li>$\mathcal{G}_2$（迹零子群）在扩域中，但可以通过扭曲曲线优化</li>
<li>它们线性独立，配对 $e : \mathcal{G}_1 \times \mathcal{G}_2 \to \mu_r$ 是非退化的</li>
</ul>

<blockquote>
<strong>总结</strong>：
<ul>
<li>$\pi$ 是 Frobenius 自同态，$(x,y) \mapsto (x^q, y^q)$</li>
<li>$\pi - [1]$ 和 $\pi - [q]$ 是自同态环中的元素（自同态的加法）</li>
<li>$\text{Ker}(\pi - [1]) = E(\mathbb{F}_q)$ 是基域点（Frobenius 不动点）</li>
<li>$\text{Ker}(\pi - [q])$ 是特征值 $q$ 的特征空间（迹零子群）</li>
<li>$E[r] = \mathcal{G}_1 \oplus \mathcal{G}_2$ 是两个特征空间的直和</li>
<li>Type 3 配对利用这个自然分解：$\mathbb{G}_1 = \mathcal{G}_1$，$\mathbb{G}_2 = \mathcal{G}_2$</li>
</ul>
</blockquote>

<!-- ==================== Section 4.3 ==================== -->
<h1>4.3 Twisted curves</h1>
<h2>4.3 扭曲曲线</h2>

<p>Before moving our focus to the algorithm for computing pairings, we have one final point to discuss; namely, the most efficient way to hash to, and represent elements in $\mathbb{G}_2$. This discussion brings up the crucial notion of <em>twists</em> of elliptic curves, which was first applied to pairings by Barreto et al. [BLS03]. We start with an example.</p>

<blockquote>
<strong>扭曲曲线（Twisted Curves）</strong>：高效哈希和表示 $\mathbb{G}_2$ 元素的关键技术，由 Barreto 等人首次应用于配对。
</blockquote>

<div class="example">
<p><span class="example-title">Example 4.3.1</span> (Magma script). Recall the curve used in Example 4.1.1: $q = 11$, $E/\mathbb{F}_q : y^2 = x^3 + 4$, $\#E(\mathbb{F}_q) = 12$ and $r = 3$. Excluding $\mathcal{O}$, the trace zero subgroup $\mathcal{G}_2$ consists of points defined in $E(\mathbb{F}_{q^2})$, namely $(8, i)$ and $(8, 10i)$. Define the curve $E'/\mathbb{F}_q : y^2 = x^3 - 4$ and observe that the map $\Psi^{-1}$ defined by $\Psi^{-1}: (x, y) \mapsto (-x, iy)$ takes points from $E$ to $E'$, i.e. $\Psi^{-1}: E \to E'$. Restricting $\Psi^{-1}$ to $\mathcal{G}_2$ actually gives a map that takes elements defined over $\mathbb{F}_{q^2}$ to elements defined over $\mathbb{F}_q$: $\Psi^{-1}((8, i)) = (3, 10)$ and $\Psi^{-1}((8, 10i)) = (3, 1)$. The convention is to write $\Psi$ for the reverse map $\Psi : E' \to E$ which in this case is defined by $\Psi : (x', y') \mapsto (-x', y'/i) = (-x', -y'i)$. We call $E'$ a <em>twist</em> of $E$. Every twist</p>
</div>

<!-- ==================== PAGE 62 ==================== -->
<div class="page-marker">— 62 —</div>

<div class="example">
<p>has a degree $d$, which tells us the extension field of $\mathbb{F}_q$ where $E$ and $E'$ become isomorphic. For our purposes, $d$ is also the degree of its field of definition of $E'$ as a subfield of $\mathbb{F}_{q^k}$, i.e. a degree $d$ twist $E'$ of $E$ will be defined over $\mathbb{F}_{q^{k/d}}$. In this example, $k = 2$ and $E'$ is defined over $\mathbb{F}_q$, so we are using a $d = 2$ twist, called a <em>quadratic twist</em>. Ordinarily, computations in the group $\mathbb{G}_2 = \mathcal{G}_2$ would</p>
</div>

<figure style="text-align: center; margin: 30px 0;">
  <img src="images/fig4_11.svg" alt="Figure 4.11: E and quadratic twist E'" style="max-width: 700px;">
  <figcaption>Figure 4.11: $E$ (left) and the quadratic twist $E'$ (right).</figcaption>
</figure>

<div class="example">
<p>require (point doubling/addition) operations in the extension field $\mathbb{F}_{q^2}$, but we can use $\Psi^{-1}$ to instead perform these operations in $E'(\mathbb{F}_q)$, before mapping the result back with $\Psi$. Moreover, if we restrict the maps to $E[r]$, then $\Psi^{-1}$ takes elements of the trace zero subgroup $\mathcal{G}_2$ of $E$ and moves them to the base field subgroup $\mathcal{G}_1'$ of $E'$. Note that computing $\Psi$ and $\Psi^{-1}$ is essentially cost free.</p>
</div>

<blockquote>
<strong>例 4.3.1</strong>：二次扭曲（Quadratic Twist）。
<ul>
<li>$E: y^2 = x^3 + 4$，扭曲曲线 $E': y^2 = x^3 - 4$</li>
<li>$\Psi^{-1}: (x, y) \mapsto (-x, iy)$ 将 $E$ 上的点映到 $E'$</li>
<li>关键：$\Psi^{-1}$ 将 $\mathcal{G}_2 \subset E(\mathbb{F}_{q^2})$ 映到 $E'(\mathbb{F}_q)$！</li>
</ul>
<p><strong>好处</strong>：原本需要在 $\mathbb{F}_{q^2}$ 中做的 $\mathbb{G}_2$ 群运算，现在可以在 $\mathbb{F}_q$ 中做！</p>
<p>$\Psi$ 和 $\Psi^{-1}$ 的计算几乎没有代价。</p>
</blockquote>

<p>We give a larger example that better illustrates the power of employing twisted curves.</p>

<div class="example">
<p><span class="example-title">Example 4.3.2</span> (Magma script). Let $q = 103$ and consider $E/\mathbb{F}_q : y^2 = x^3 + 72$, which has $\#E(\mathbb{F}_q) = 84$, so let $r = 7$. The embedding degree (with respect to $r$) is $k = 6$, so form $\mathbb{F}_{q^6} = \mathbb{F}_q(u)$ with $u^6 + 2 = 0$. The trace zero subgroup $\mathcal{G}_2 = E[r] \cap \text{Ker}(\pi - [q])$ is defined over $\mathbb{F}_{q^6}$, and is generated by $(35u^4, 42u^3)$ (see Figure 4.12). We define the degree $d = 6$ sextic twist $E'$ of $E$ as $E': y^2 = x^3 + 72u^6$, where the back-and-forth isomorphisms are defined as $\Psi : E' \to E$, $(x', y') \mapsto (x'/u^2, y'/u^3)$ and $\Psi^{-1} : E \to E'$, $(x, y) \mapsto (u^2 x, u^3 y)$. Observe that $\Psi^{-1}$ maps elements in $\mathcal{G}_2 \in E(\mathbb{F}_{q^k})[r] = E(\mathbb{F}_{q^6})[r]$ to elements in $E'(\mathbb{F}_{q^{k/d}})[r] = E'(\mathbb{F}_q)[r]$. Thus, when performing group operations in $\mathbb{G}_2 = \mathcal{G}_2$, we gain the advantage of working over</p>
</div>

<!-- ==================== PAGE 63 ==================== -->
<div class="page-marker">— 63 —</div>

<figure style="text-align: center; margin: 30px 0;">
  <img src="images/fig4_12.svg" alt="Figure 4.12: E and sextic twist E'" style="max-width: 750px;">
  <figcaption>Figure 4.12: $E$ (left) and the (correct) sextic twist $E'$ (right)</figcaption>
</figure>

<div class="example">
<p>$\mathbb{F}_q$ instead of $\mathbb{F}_{q^6}$, a dramatic improvement in computational complexity.</p>
</div>

<blockquote>
<strong>例 4.3.2</strong>：六次扭曲（Sextic Twist）——巨大的效率提升！
<ul>
<li>$k = 6$，$\mathcal{G}_2$ 定义在 $\mathbb{F}_{q^6}$ 上</li>
<li>六次扭曲 $E': y^2 = x^3 + 72u^6$</li>
<li>$\Psi^{-1}$ 将 $\mathcal{G}_2 \subset E(\mathbb{F}_{q^6})$ 映到 $E'(\mathbb{F}_q)$</li>
</ul>
<p><strong>效果</strong>：在 $\mathbb{F}_q$ 而非 $\mathbb{F}_{q^6}$ 中计算——计算复杂度的巨大改进！</p>
</blockquote>

<p>In both Example 4.3.1 and Example 4.3.2 above, we had $k = d$, so the twist allowed us to work in the base field $\mathbb{F}_q$, rather than $\mathbb{F}_{q^k}$. In the general case though, the twist will pull computations back into the subfield $\mathbb{F}_{q^{k/d}}$ of $\mathbb{F}_{q^k}$. For example, if the embedding degree was $k = 12$, a quadratic twist ($d = 2$) would allow computations in $\mathbb{G}_2$ to be performed in $\mathbb{F}_{q^6}$ rather than $\mathbb{F}_{q^{12}}$, whilst a sextic twist ($d = 6$) would allow us to instead work in $\mathbb{F}_{q^2}$. Thus, we would clearly prefer the degree $d$ of the twist to be as high as possible. As it turns out, $d = 6$ is the highest degree available on elliptic curves, where the only possibilities are $d \in \{2, 3, 4, 6\}$ [Sil09, Prop. X.5.4]. For $d > 2$, we also require special subclasses of curves that depend on $d$, so following [Sil09, Prop. X.5.4] (see also [HSV06, Prop. 6, Prop. 8]) we describe all four cases individually. In the general case according to our context, a twist of $E : y^2 = x^3 + ax + b$ is given by $E': y^2 = x^3 + a\omega^4 x + b\omega^6$, with $\Psi : E' \to E : (x', y') \mapsto (x'/\omega^2, y'/\omega^3)$, $\omega \in \mathbb{F}_{q^k}$. We can only achieve specific degrees $d$ through combinations of zero and non-zero values for $a$ and $b$.</p>

<blockquote>
<strong>扭曲度数 $d$ 的选择</strong>：
<ul>
<li>椭圆曲线上可用的扭曲度数：$d \in \{2, 3, 4, 6\}$</li>
<li>$d$ 越大，效率越高（$\mathbb{F}_{q^{k/d}}$ 越小）</li>
<li>$d > 2$ 需要曲线满足特定形式</li>
</ul>

<p>一般形式：$E: y^2 = x^3 + ax + b$ 的扭曲是 $E': y^2 = x^3 + a\omega^4 x + b\omega^6$</p>
</blockquote>

<div class="type-box">
<div class="type-title">$d = 2$ quadratic twists（二次扭曲）</div>
<p>Quadratic twists are available on <strong>any</strong> elliptic curve, so if $E/\mathbb{F}_q : y^2 = x^3 + ax + b$, then a quadratic twist is given by $E'/\mathbb{F}_{q^{k/2}} : y^2 = x^3 + a\omega^4 x + b\omega^6$, with $\omega \in \mathbb{F}_{q^k}$ but $\omega^2 \in \mathbb{F}_{q^{k/2}}$. Since $\omega^3 \in \mathbb{F}_{q^k}$, the isomorphism $\Psi : E' \to E$ defined by $\Psi : (x', y') \mapsto (x'/\omega^2, y'/\omega^3)$ will take elements in $E'(\mathbb{F}_{q^{k/2}})$ to elements in $E(\mathbb{F}_{q^k})$, whilst $\Psi^{-1}$ will do the</p>
</div>

<!-- ==================== PAGE 64 ==================== -->
<div class="page-marker">— 64 —</div>

<div class="type-box">
<p>opposite.</p>
</div>

<div class="type-box">
<div class="type-title">$d = 3$ cubic twists（三次扭曲）</div>
<p>Degree $d = 3$ twists can only occur when $a = 0$, so if $E/\mathbb{F}_q : y^2 = x^3 + b$, then $E'/\mathbb{F}_{q^{k/3}} : y^2 = x^3 + b\omega^6$, with $\omega^3, \omega^6 \in \mathbb{F}_{q^{k/3}}$, but $\omega^2 \in \mathbb{F}_{q^k} \setminus \mathbb{F}_{q^{k/3}}$. Thus, the isomorphism $\Psi : E' \to E$ (defined as usual) will take elements in $E'(\mathbb{F}_{q^{k/3}})$ to elements in $E(\mathbb{F}_{q^k})$, whilst $\Psi^{-1}$ does the opposite.</p>
</div>

<div class="type-box">
<div class="type-title">$d = 4$ quartic twists（四次扭曲）</div>
<p>Degree $d = 4$ twists are available when $b = 0$, so if $E/\mathbb{F}_q : y^2 = x^3 + ax$, then $E'/\mathbb{F}_{q^{k/4}} : y^2 = x^3 + a\omega^4 x$, with $\omega^4 \in \mathbb{F}_{q^{k/4}}$, $\omega^2 \in \mathbb{F}_{q^{k/2}}$ and $\omega^3 \in \mathbb{F}_{q^k} \setminus \mathbb{F}_{q^{k/2}}$. Thus, $\Psi$ will move elements in $E'(\mathbb{F}_{q^{k/4}})$ up to elements in $E(\mathbb{F}_{q^k})$, whilst $\Psi^{-1}$ will move elements from $E(\mathbb{F}_{q^k})$ down to $E'(\mathbb{F}_{q^{k/4}})$.</p>
</div>

<div class="type-box">
<div class="type-title">$d = 6$ sextic twists（六次扭曲）</div>
<p>Sextic twists are only available when $a = 0$, so if $E/\mathbb{F}_q : y^2 = x^3 + b$, then $E'/\mathbb{F}_{q^{k/6}} : y^2 = x^3 + b\omega^6$, with $\omega^6 \in \mathbb{F}_{q^{k/6}}$, $\omega^3 \in \mathbb{F}_{q^{k/3}}$ and $\omega^2 \in \mathbb{F}_{q^{k/2}}$. Thus, $\Psi$ pushes elements in $E'(\mathbb{F}_{q^{k/6}})$ up to $E(\mathbb{F}_{q^k})$, whilst $\Psi^{-1}$ pulls elements from $E(\mathbb{F}_{q^k})$ all the way down to $E'(\mathbb{F}_{q^{k/6}})$.</p>
</div>

<blockquote>
<strong>扭曲类型总结</strong>：
<table border="1" style="border-collapse: collapse; width: 100%; margin: 10px 0;">
<tr><th>扭曲度数 $d$</th><th>曲线形式要求</th><th>$\mathbb{G}_2$ 计算域</th></tr>
<tr><td>2（二次）</td><td>任意 $y^2 = x^3 + ax + b$</td><td>$\mathbb{F}_{q^{k/2}}$</td></tr>
<tr><td>3（三次）</td><td>$a = 0$：$y^2 = x^3 + b$</td><td>$\mathbb{F}_{q^{k/3}}$</td></tr>
<tr><td>4（四次）</td><td>$b = 0$：$y^2 = x^3 + ax$</td><td>$\mathbb{F}_{q^{k/4}}$</td></tr>
<tr><td>6（六次）</td><td>$a = 0$：$y^2 = x^3 + b$</td><td>$\mathbb{F}_{q^{k/6}}$</td></tr>
</table>
<p>例如：$k = 12$ 时，六次扭曲允许在 $\mathbb{F}_{q^2}$ 中计算，而非 $\mathbb{F}_{q^{12}}$！</p>
</blockquote>

<p>We make the remark that, for our purposes, a specific twist can only be applied if the curve is of the corresponding form above and the embedding degree $k$ has $d$ as a factor. Thus, attractive embedding degrees are those which have any of $d = \{2, 3, 4, 6\}$ as factors, but preferably $d = 4$ or $d = 6$ for increased performance. This will be discussed in detail in Chapter 6. Very fortunately, we will also see in that chapter that almost all of the popular techniques for constructing curves suitable for pairing computation give rise to curves of the form $y^2 = x^3 + b$ or $y^2 = x^3 + ax$, which facilitate the high-degree twists above.</p>

<blockquote>
<strong>理想的嵌入度</strong>：能被 $d \in \{4, 6\}$ 整除的 $k$ 值最佳。

<p><strong>幸运的是</strong>：几乎所有流行的配对友好曲线构造方法都产生 $y^2 = x^3 + b$ 或 $y^2 = x^3 + ax$ 形式的曲线，恰好支持高度数扭曲！</p>
</blockquote>

<!-- ==================== Section 4.4 ==================== -->
<h1>4.4 Chapter summary</h1>
<h2>4.4 章节总结</h2>

<p>We started by discussing that cryptographic pairings are bilinear maps from two elliptic curve groups to a third (finite field) group $e : \mathbb{G}_1 \times \mathbb{G}_2 \to \mathbb{G}_T$. We then claimed that, in general, to define a useful pairing on $\mathbb{G}_1$ and $\mathbb{G}_2$, we must be able to define more than one subgroup in the $r$-torsion of $E$, where the most cryptographically useful case is that $r$ is a large prime. We then defined the embedding degree $k$ of $E$ (with respect to $r$), and showed that we must extend</p>

<!-- ==================== PAGE 65 ==================== -->
<div class="page-marker">— 65 —</div>

<p>the field $\mathbb{F}_q$ to $\mathbb{F}_{q^k}$ in order to find more than one such subgroup. In fact, we showed that $E(\mathbb{F}_{q^k})$ actually contains the entire $r$-torsion, which has cardinality $r^2$ and consists of $r+1$ cyclic subgroups of order $r$. These $r+1$ subgroups (and the existence of maps between them) facilitate several choices for the definitions of $\mathbb{G}_1$ and $\mathbb{G}_2$, which gives rise to four pairing types. We argued that the most popular pairing type is a Type 3 pairing, which sets $\mathbb{G}_1$ and $\mathbb{G}_2$ as the two eigenspaces of the Frobenius endomorphism, namely $\mathbb{G}_1 = \mathcal{G}_1 = E[r] \cap \text{Ker}(\pi - [1])$ is the base field subgroup, and $\mathbb{G}_2 = \mathcal{G}_2 = E[r] \cap \text{Ker}(\pi - [q])$ is the trace zero subgroup.</p>

<p>The definitions of the Weil and Tate pairings in the next chapter inherently justify the claim we made in this chapter that, in general, the arguments $P$ and $Q$ in the pairing $e(P, Q)$ must come from distinct torsion subgroups.</p>

<blockquote>
<strong>第四章总结</strong>：
<ol>
<li><strong>配对</strong>是双线性映射 $e : \mathbb{G}_1 \times \mathbb{G}_2 \to \mathbb{G}_T$</li>
<li>需要在 $E$ 的 $r$-挠群中定义多个子群</li>
<li><strong>嵌入度</strong> $k$：使得 $E[r] \subset E(\mathbb{F}_{q^k})$ 的最小正整数</li>
<li>$E[r] \cong \mathbb{Z}_r \times \mathbb{Z}_r$，包含 $r+1$ 个循环子群</li>
<li><strong>四种配对类型</strong>取决于 $\mathbb{G}_2$ 的选择</li>
<li><strong>Type 3</strong> 是实践中最流行的选择：
   <ul>
   <li>$\mathbb{G}_1 = \mathcal{G}_1 = E[r] \cap \text{Ker}(\pi - [1])$（基域子群）</li>
   <li>$\mathbb{G}_2 = \mathcal{G}_2 = E[r] \cap \text{Ker}(\pi - [q])$（迹零子群）</li>
   </ul>
</li>
<li><strong>扭曲曲线</strong>允许在更小的域中执行 $\mathbb{G}_2$ 的运算</li>
<li>配对 $e(P, Q)$ 的参数必须来自<strong>不同的挠群子群</strong></li>
</ol>

<p><strong>下一章预告</strong>：Weil 和 Tate 配对的定义将解释为什么 $P$ 和 $Q$ 必须来自不同子群。</p>
</blockquote>

<div class="footnote">
<p><sup>3</sup>There are some protocols whose security actually relies on the inability to compute $\psi$ efficiently.</p>
</div>

<div class="nav-links">
    <a href="ch4-1.html">← 上一部分：r-挠群</a>
    <span></span>
</div>

</body>
</html>
