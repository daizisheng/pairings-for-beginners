<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>yÂ³ = x çš„å‘é‡åœºæ¼”ç¤º</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        h2 {
            color: #333;
            margin-top: 40px;
            margin-bottom: 10px;
        }

        .description {
            max-width: 1400px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .description h3 {
            margin-top: 0;
            color: #2c3e50;
            font-size: 18px;
        }

        .description h4 {
            margin-top: 15px;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .description p {
            margin: 5px 0;
            color: #555;
            line-height: 1.6;
        }

        .main-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            margin-bottom: 40px;
        }

        .canvas-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .canvas-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .controls {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 20px;
            min-width: 250px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: bold;
        }

        .control-group input[type="range"] {
            width: 100%;
        }

        .control-group .value {
            color: #666;
            font-size: 14px;
        }

        svg {
            border: 1px solid #ddd;
        }

        svg text {
            text-rendering: geometricPrecision;
            shape-rendering: geometricPrecision;
            font-family: Arial, sans-serif;
        }

        .legend {
            margin-top: 15px;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }

        .legend p {
            margin: 5px 0;
            font-size: 13px;
            line-height: 1.5;
        }

        #threejs-container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }

        .sphere-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        .separator {
            width: 100%;
            max-width: 1400px;
            height: 2px;
            background: linear-gradient(to right, transparent, #ddd, transparent);
            margin: 40px 0;
        }
    </style>
</head>
<body>
    <h1>å¤å‡½æ•° yÂ³ = x çš„å‘é‡åœºå¯è§†åŒ–</h1>

    <div class="description" style="background-color: #e8f4f8; padding: 15px; border-left: 4px solid #2196F3; margin-bottom: 20px;">
        <h3>ğŸ“ å¤ç«‹æ–¹æ ¹å‡½æ•°çš„ä¸‰ä¸ªåˆ†æ”¯</h3>
        <p><strong>å¯¹äºå¤æ•° \(x = r \cdot e^{i\theta}\)ï¼Œå…¶ä¸­ \(r = |x|\)ï¼Œ\(\theta = \arg(x) \in (-\pi, \pi]\)</strong></p>

        <h4 style="color: #2563eb;">ğŸ”µ ä¸»å€¼åˆ†æ”¯ \(\sqrt[3]{x}\)ï¼ˆè“è‰²ï¼‰</h4>
        <p style="margin-left: 20px; font-size: 16px;">
            \[y_0 = \sqrt[3]{x} = r^{1/3} \cdot e^{i\theta/3}\]
        </p>

        <h4 style="color: #dc2626;">ğŸ”´ ç¬¬äºŒåˆ†æ”¯ \(\omega \sqrt[3]{x}\)ï¼ˆçº¢è‰²ï¼‰</h4>
        <p style="margin-left: 20px; font-size: 16px;">
            \[y_1 = r^{1/3} \cdot e^{i(\theta/3 + 2\pi/3)}\]
        </p>

        <h4 style="color: #16a34a;">ğŸŸ¢ ç¬¬ä¸‰åˆ†æ”¯ \(\omega^2 \sqrt[3]{x}\)ï¼ˆç»¿è‰²ï¼‰</h4>
        <p style="margin-left: 20px; font-size: 16px;">
            \[y_2 = r^{1/3} \cdot e^{i(\theta/3 + 4\pi/3)}\]
        </p>

        <p style="margin-top: 15px;"><strong>è¯´æ˜ï¼š</strong>å…¶ä¸­ \(\omega = e^{2\pi i/3}\) æ˜¯ä¸‰æ¬¡å•ä½æ ¹ã€‚ä¸‰ä¸ªåˆ†æ”¯åœ¨å¤å¹³é¢ä¸Šç›¸å·® \(120Â°\) çš„æ—‹è½¬ã€‚</p>
    </div>

    <div class="description">
        <h3>2D è§†å›¾è¯´æ˜</h3>
        <p><strong>å‡½æ•°ï¼š</strong>\(y^3 = x\)ï¼Œå³ \(y = \sqrt[3]{x}\)ï¼Œå…¶ä¸­ \(x, y \in \mathbb{C}\)</p>
        <p><strong>å¤å¹³é¢è§†å›¾ï¼š</strong>åœ¨å¤å¹³é¢ä¸Šå±•ç¤ºå‡½æ•°çš„å‘é‡åœºã€‚å¯¹äºæ¯ä¸ªç½‘æ ¼ç‚¹ \(x\)ï¼Œåœ¨è¯¥ç‚¹å¤„ç»˜åˆ¶å‘é‡ \(y = \sqrt[3]{x}\) çš„ä¸‰ä¸ªåˆ†æ”¯å€¼ã€‚</p>
        <p><strong>åˆ†æ”¯æ ‡è®°ï¼š</strong>è“è‰²è¡¨ç¤ºä¸»å€¼åˆ†æ”¯ï¼Œçº¢è‰²è¡¨ç¤ºç¬¬äºŒåˆ†æ”¯ï¼Œç»¿è‰²è¡¨ç¤ºç¬¬ä¸‰åˆ†æ”¯ã€‚</p>
    </div>

    <div class="main-container">
        <div class="canvas-container">
            <div class="canvas-title">å¤å¹³é¢å‘é‡åœº</div>
            <svg id="canvas1" width="600" height="600"></svg>
        </div>

        <div class="controls">
            <h3 style="margin-top: 0;">2D æ§åˆ¶é¢æ¿</h3>

            <div class="control-group">
                <label>ç½‘æ ¼å¯†åº¦</label>
                <input type="range" id="gridDensity" min="5" max="30" value="15" step="1">
                <div class="value">å½“å‰: <span id="gridDensityValue">15</span></div>
            </div>

            <div class="control-group">
                <label>ç¼©æ”¾å› å­</label>
                <input type="range" id="scale" min="20" max="80" value="45" step="5">
                <div class="value">å½“å‰: <span id="scaleValue">45</span></div>
            </div>

            <div class="control-group">
                <label>ç®­å¤´é•¿åº¦æ¯”ä¾‹</label>
                <input type="range" id="arrowScale" min="10" max="300" value="80" step="10">
                <div class="value">å½“å‰: <span id="arrowScaleValue">80</span>%</div>
            </div>

            <div class="control-group">
                <label style="font-weight: bold; margin-bottom: 8px;">æ˜¾ç¤ºåˆ†æ”¯ï¼š</label>
                <label style="display: block; font-weight: normal; margin-bottom: 5px;">
                    <input type="radio" name="displayMode2D" value="all" checked>
                    æ˜¾ç¤ºæ‰€æœ‰ä¸‰ä¸ªåˆ†æ”¯
                </label>
                <label style="display: block; font-weight: normal; margin-bottom: 5px;">
                    <input type="radio" name="displayMode2D" value="onlyBranch0">
                    åªæ˜¾ç¤º \(\sqrt[3]{x}\)
                </label>
                <label style="display: block; font-weight: normal; margin-bottom: 5px;">
                    <input type="radio" name="displayMode2D" value="onlyBranch1">
                    åªæ˜¾ç¤º \(\omega\sqrt[3]{x}\)
                </label>
                <label style="display: block; font-weight: normal;">
                    <input type="radio" name="displayMode2D" value="onlyBranch2">
                    åªæ˜¾ç¤º \(\omega^2\sqrt[3]{x}\)
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showGrid" checked>
                    æ˜¾ç¤ºç½‘æ ¼
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showAxes" checked>
                    æ˜¾ç¤ºåæ ‡è½´
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showCircles" checked>
                    æ˜¾ç¤ºå‚è€ƒåœ†
                </label>
            </div>

            <div class="legend">
                <strong>è¯´æ˜</strong>
                <p>â€¢ æ¯ä¸ªç®­å¤´ä»ç½‘æ ¼ç‚¹ \(x\) å‡ºå‘</p>
                <p>â€¢ ç®­å¤´æ–¹å‘å’Œé•¿åº¦è¡¨ç¤º \(y = \sqrt[3]{x}\)</p>
                <p>â€¢ ä¸‰ç§é¢œè‰²è¡¨ç¤ºä¸‰ä¸ªä¸åŒçš„åˆ†æ”¯</p>
                <p>â€¢ å¯è°ƒæ•´å¯†åº¦ã€ç¼©æ”¾å’Œç®­å¤´é•¿åº¦</p>
            </div>
        </div>
    </div>

    <div class="separator"></div>

    <h2>3D é»æ›¼çƒå¯è§†åŒ–</h2>

    <div class="description">
        <h3>3D é»æ›¼çƒè¯´æ˜</h3>
        <p><strong>ç«‹ä½“æŠ•å½±ï¼š</strong>å¤å¹³é¢é€šè¿‡ç«‹ä½“æŠ•å½±ä»åŒ—ææ˜ å°„åˆ°çƒé¢ã€‚å¤å¹³é¢ä¸Šçš„ç‚¹ \(z = x + iy\) å¯¹åº”çƒé¢ä¸Šçš„ç‚¹ã€‚</p>
        <p><strong>ç‰¹æ®Šç‚¹æ ‡æ³¨ï¼š</strong>çº¢è‰² - åŸç‚¹(0)ï¼Œè“è‰² - å®è½´(Â±1)ï¼Œç»¿è‰² - è™šè½´(Â±i)ï¼Œç´«è‰² - æ— ç©·è¿œç‚¹(âˆ)åœ¨åŒ—æã€‚</p>
        <p><strong>å‘é‡åœºï¼š</strong>åœ¨çƒé¢ä¸Šçš„æ¯ä¸ªé‡‡æ ·ç‚¹ï¼Œæ˜¾ç¤ºå¯¹åº”çš„å‘é‡ \(y = \sqrt[3]{x}\)ã€‚å‘é‡è¢«æ˜ å°„åˆ°çƒé¢çš„åˆ‡ç©ºé—´ä¸­ï¼Œä½¿ç”¨å¹³é¢è§£é‡Šï¼ˆ1â†’å³ï¼Œiâ†’ä¸Šï¼‰ã€‚</p>
        <p><strong>äº¤äº’ï¼š</strong>ä½¿ç”¨é¼ æ ‡æ‹–æ‹½æ—‹è½¬ï¼Œæ»šè½®ç¼©æ”¾ã€‚</p>
    </div>

    <div class="sphere-container">
        <div id="threejs-container">
            <div class="canvas-title" style="margin-bottom: 15px;">3D é»æ›¼çƒï¼ˆå¯äº¤äº’ï¼‰</div>
            <div id="threejs-canvas"></div>
        </div>

        <div class="controls">
            <h3 style="margin-top: 0;">3D æ§åˆ¶é¢æ¿</h3>

            <div class="control-group">
                <label>çƒé¢é‡‡æ ·å¯†åº¦</label>
                <input type="range" id="samplingRange" min="8" max="32" value="16" step="2">
                <div class="value">å½“å‰: <span id="samplingRangeValue">16</span></div>
            </div>

            <div class="control-group">
                <label>å‘é‡é•¿åº¦</label>
                <input type="range" id="vectorLength" min="5" max="50" value="25" step="1">
                <div class="value">å½“å‰: <span id="vectorLengthValue">25</span>%</div>
            </div>

            <div class="control-group">
                <label style="font-weight: bold; margin-bottom: 8px;">æ˜¾ç¤ºåˆ†æ”¯ï¼š</label>
                <label style="display: block; font-weight: normal; margin-bottom: 5px;">
                    <input type="radio" name="displayMode3D" value="both" checked>
                    æ˜¾ç¤ºæ‰€æœ‰ä¸‰ä¸ªåˆ†æ”¯
                </label>
                <label style="display: block; font-weight: normal; margin-bottom: 5px;">
                    <input type="radio" name="displayMode3D" value="onlyBranch0">
                    åªæ˜¾ç¤º \(\sqrt[3]{x}\)
                </label>
                <label style="display: block; font-weight: normal; margin-bottom: 5px;">
                    <input type="radio" name="displayMode3D" value="onlyBranch1">
                    åªæ˜¾ç¤º \(\omega\sqrt[3]{x}\)
                </label>
                <label style="display: block; font-weight: normal;">
                    <input type="radio" name="displayMode3D" value="onlyBranch2">
                    åªæ˜¾ç¤º \(\omega^2\sqrt[3]{x}\)
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showSphere" checked>
                    æ˜¾ç¤ºçƒé¢
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showWireframe" checked>
                    æ˜¾ç¤ºç½‘æ ¼çº¿
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="showAxesHelper" checked>
                    æ˜¾ç¤ºåæ ‡è½´
                </label>
            </div>

            <div class="legend">
                <strong>æ ‡æ³¨è¯´æ˜</strong>
                <p style="color: #ff0000;">â€¢ çº¢ç‚¹ï¼š0ï¼ˆå—æï¼‰</p>
                <p style="color: #0000ff;">â€¢ è“ç‚¹ï¼š1, -1</p>
                <p style="color: #00aa00;">â€¢ ç»¿ç‚¹ï¼ši, -i</p>
                <p style="color: #aa00aa;">â€¢ ç´«ç‚¹ï¼šâˆï¼ˆåŒ—æï¼‰</p>
                <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                <strong>äº¤äº’æç¤º</strong>
                <p>â€¢ æ‹–æ‹½æ—‹è½¬è§†è§’</p>
                <p>â€¢ æ»šè½®ç¼©æ”¾</p>
            </div>
        </div>
    </div>

    <div class="separator"></div>

    <h2>é»æ›¼é¢æ„é€ è¿‡ç¨‹</h2>

    <div class="description">
        <h3>é»æ›¼é¢çš„æ‹“æ‰‘æ„é€ </h3>
        <p><strong>åŸºæœ¬æ€æƒ³ï¼š</strong>\(y^3 = x\) å®šä¹‰äº†ä¸€ä¸ªä¸‰å€¼å‡½æ•°ï¼Œæ¯ä¸ª \(x\) å¯¹åº”ä¸‰ä¸ª \(y\) å€¼ã€‚ä¸ºäº†ä½¿å…¶å•å€¼åŒ–ï¼Œéœ€è¦æ„é€ ä¸€ä¸ªé»æ›¼é¢ã€‚</p>
        <p><strong>æ„é€ æ–¹æ³•ï¼š</strong>å–ä¸‰ä¸ªé»æ›¼çƒï¼ˆå¯¹åº”ä¸‰ä¸ªåˆ†æ”¯ï¼‰ï¼Œæ²¿ç€åˆ†æ”¯åˆ‡å‰²çº¿ï¼ˆä»0åˆ°\(-\infty\)çš„è´Ÿå®è½´ï¼‰åˆ‡å¼€ï¼Œç„¶åæŒ‰å¾ªç¯é¡ºåºç¼åˆã€‚</p>
        <p><strong>ç»“æœï¼š</strong>å½¢æˆä¸€ä¸ªå…·æœ‰ç‰¹å®šæ‹“æ‰‘ç»“æ„çš„æ›²é¢ï¼Œä½¿å¾—å‡½æ•°åœ¨è¯¥æ›²é¢ä¸Šå•å€¼ä¸”è¿ç»­ã€‚åœ¨èµ¤é“ä¸Šç»•è¡Œä¸‰åœˆæ‰èƒ½å›åˆ°èµ·ç‚¹ã€‚</p>
    </div>

    <div class="sphere-container">
        <div id="threejs-container-construction">
            <div class="canvas-title" style="margin-bottom: 15px;">é»æ›¼é¢æ„é€ åŠ¨ç”»</div>
            <div id="construction-canvas"></div>
        </div>

        <div class="controls">
            <h3 style="margin-top: 0;">æ„é€ æ­¥éª¤æ§åˆ¶</h3>

            <div class="control-group">
                <div id="stepLabel" style="margin-bottom: 15px; color: #333; font-size: 14px; line-height: 1.6; font-weight: bold;">
                    æ­¥éª¤ 1/5ï¼šä¸‰ä¸ªç‹¬ç«‹çš„é»æ›¼çƒ
                </div>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button id="prevStep" style="flex: 1; padding: 10px; font-size: 14px; background-color: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        â† ä¸Šä¸€æ­¥
                    </button>
                    <button id="nextStep" style="flex: 1; padding: 10px; font-size: 14px; background-color: #2563eb; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        ä¸‹ä¸€æ­¥ â†’
                    </button>
                </div>
            </div>

            <div class="control-group">
                <label>çƒé¢é‡‡æ ·å¯†åº¦</label>
                <input type="range" id="constructionSampling" min="8" max="32" value="10" step="2">
                <div class="value">å½“å‰: <span id="constructionSamplingValue">10</span></div>
            </div>

            <div class="control-group">
                <label>å‘é‡é•¿åº¦</label>
                <input type="range" id="constructionVectorLength" min="5" max="50" value="15" step="1">
                <div class="value">å½“å‰: <span id="constructionVectorLengthValue">15</span>%</div>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="constructionShowSphere" checked>
                    æ˜¾ç¤ºçƒé¢
                </label>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="constructionShowWireframe" checked>
                    æ˜¾ç¤ºç½‘æ ¼çº¿
                </label>
            </div>

            <div class="legend">
                <strong>æ„é€ æ­¥éª¤è¯´æ˜</strong>
                <p>1. ä¸‰ä¸ªç‹¬ç«‹çš„é»æ›¼çƒï¼ˆ\(\sqrt[3]{x}\)ã€\(\omega\sqrt[3]{x}\)ã€\(\omega^2\sqrt[3]{x}\)ï¼‰</p>
                <p>2. æ ‡è®°åˆ†æ”¯åˆ‡å‰²çº¿ï¼ˆè´Ÿå®è½´ï¼‰</p>
                <p>3. æ²¿åˆ‡å‰²çº¿åˆ‡å¼€</p>
                <p>4. å‡†å¤‡å¾ªç¯ç¼åˆ</p>
                <p>5. å®Œæˆç¼åˆå½¢æˆé»æ›¼é¢</p>
                <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                <p style="color: #2563eb;">â€¢ è“è‰²ç®­å¤´ï¼š\(\sqrt[3]{x}\) åˆ†æ”¯</p>
                <p style="color: #dc2626;">â€¢ çº¢è‰²ç®­å¤´ï¼š\(\omega\sqrt[3]{x}\) åˆ†æ”¯</p>
                <p style="color: #16a34a;">â€¢ ç»¿è‰²ç®­å¤´ï¼š\(\omega^2\sqrt[3]{x}\) åˆ†æ”¯</p>
            </div>
        </div>
    </div>

    <script>
        // ==================== 2D éƒ¨åˆ† ====================
        const svg1 = document.getElementById('canvas1');
        const width = 600;
        const height = 600;
        const centerX = width / 2;
        const centerY = height / 2;

        // 2D æ§åˆ¶å…ƒç´ 
        const gridDensityInput = document.getElementById('gridDensity');
        const scaleInput = document.getElementById('scale');
        const arrowScaleInput = document.getElementById('arrowScale');
        const showGridCheckbox = document.getElementById('showGrid');
        const showAxesCheckbox = document.getElementById('showAxes');
        const showCirclesCheckbox = document.getElementById('showCircles');

        function updateValues() {
            document.getElementById('gridDensityValue').textContent = gridDensityInput.value;
            document.getElementById('scaleValue').textContent = scaleInput.value;
            document.getElementById('arrowScaleValue').textContent = arrowScaleInput.value;
        }

        // è®¡ç®—ç«‹æ–¹æ ¹ï¼ˆä¸‰ä¸ªåˆ†æ”¯ï¼‰
        function complexCubeRoot(x, y) {
            const r = Math.sqrt(x * x + y * y);
            if (r < 1e-10) {
                return [
                    { real: 0, imag: 0 },
                    { real: 0, imag: 0 },
                    { real: 0, imag: 0 }
                ];
            }

            const theta = Math.atan2(y, x);
            const cubeRootR = Math.pow(r, 1/3);

            // ä¸‰ä¸ªåˆ†æ”¯
            const results = [];
            for (let k = 0; k < 3; k++) {
                const angle = theta / 3 + (2 * Math.PI * k) / 3;
                results.push({
                    real: cubeRootR * Math.cos(angle),
                    imag: cubeRootR * Math.sin(angle)
                });
            }

            return results;
        }

        function riemannMetric(x, y) {
            const rSquared = x * x + y * y;
            return 2 / (1 + rSquared);
        }

        function getBranchColor(branchIndex) {
            const colors = ['#2563eb', '#dc2626', '#16a34a']; // è“ã€çº¢ã€ç»¿
            return colors[branchIndex];
        }

        function drawArrow(svg, x1, y1, x2, y2, color) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const length = Math.sqrt(dx * dx + dy * dy);
            if (length < 0.5) return;

            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-width', '1.5');
            line.setAttribute('opacity', '0.7');
            svg.appendChild(line);

            const angle = Math.atan2(y2 - y1, x2 - x1);
            const arrowLength = 8;
            const arrowAngle = Math.PI / 6;

            const arrow1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            const ax1 = x2 - arrowLength * Math.cos(angle - arrowAngle);
            const ay1 = y2 - arrowLength * Math.sin(angle - arrowAngle);
            arrow1.setAttribute('x1', x2);
            arrow1.setAttribute('y1', y2);
            arrow1.setAttribute('x2', ax1);
            arrow1.setAttribute('y2', ay1);
            arrow1.setAttribute('stroke', color);
            arrow1.setAttribute('stroke-width', '1.5');
            arrow1.setAttribute('opacity', '0.7');
            svg.appendChild(arrow1);

            const arrow2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            const ax2 = x2 - arrowLength * Math.cos(angle + arrowAngle);
            const ay2 = y2 - arrowLength * Math.sin(angle + arrowAngle);
            arrow2.setAttribute('x1', x2);
            arrow2.setAttribute('y1', y2);
            arrow2.setAttribute('x2', ax2);
            arrow2.setAttribute('y2', ay2);
            arrow2.setAttribute('stroke', color);
            arrow2.setAttribute('stroke-width', '1.5');
            arrow2.setAttribute('opacity', '0.7');
            svg.appendChild(arrow2);
        }

        function drawAxes(svg) {
            if (!showAxesCheckbox.checked) return;

            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', 0);
            xAxis.setAttribute('y1', centerY);
            xAxis.setAttribute('x2', width);
            xAxis.setAttribute('y2', centerY);
            xAxis.setAttribute('stroke', '#999');
            xAxis.setAttribute('stroke-width', '2');
            svg.appendChild(xAxis);

            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', centerX);
            yAxis.setAttribute('y1', 0);
            yAxis.setAttribute('x2', centerX);
            yAxis.setAttribute('y2', height);
            yAxis.setAttribute('stroke', '#999');
            yAxis.setAttribute('stroke-width', '2');
            svg.appendChild(yAxis);
        }

        function drawReferenceCircles(svg) {
            if (!showCirclesCheckbox.checked) return;

            const scale = parseFloat(scaleInput.value);
            const radii = [1, 2, 3];

            radii.forEach(r => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', centerX);
                circle.setAttribute('cy', centerY);
                circle.setAttribute('r', r * scale);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', '#ddd');
                circle.setAttribute('stroke-width', '1');
                circle.setAttribute('stroke-dasharray', '4,4');
                svg.appendChild(circle);
            });
        }

        function drawGrid(svg) {
            if (!showGridCheckbox.checked) return;

            const scale = parseFloat(scaleInput.value);
            const step = scale;

            for (let i = -width/2; i <= width/2; i += step) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', centerX + i);
                line.setAttribute('y1', 0);
                line.setAttribute('x2', centerX + i);
                line.setAttribute('y2', height);
                line.setAttribute('stroke', '#f0f0f0');
                line.setAttribute('stroke-width', '1');
                svg.appendChild(line);
            }

            for (let i = -height/2; i <= height/2; i += step) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', 0);
                line.setAttribute('y1', centerY + i);
                line.setAttribute('x2', width);
                line.setAttribute('y2', centerY + i);
                line.setAttribute('stroke', '#f0f0f0');
                line.setAttribute('stroke-width', '1');
                svg.appendChild(line);
            }
        }

        function drawVectorField(svg, useMetric) {
            const gridDensity = parseInt(gridDensityInput.value);
            const scale = parseFloat(scaleInput.value);
            const arrowScaleFactor = parseFloat(arrowScaleInput.value) / 100;

            // è·å–æ˜¾ç¤ºæ¨¡å¼
            const displayMode = document.querySelector('input[name="displayMode2D"]:checked').value;
            let branchesToShow = [];

            if (displayMode === 'all') {
                branchesToShow = [0, 1, 2];
            } else if (displayMode === 'onlyBranch0') {
                branchesToShow = [0];
            } else if (displayMode === 'onlyBranch1') {
                branchesToShow = [1];
            } else if (displayMode === 'onlyBranch2') {
                branchesToShow = [2];
            }

            const range = 5;
            const step = (2 * range) / gridDensity;

            for (let i = 0; i <= gridDensity; i++) {
                for (let j = 0; j <= gridDensity; j++) {
                    const a = -range + i * step;
                    const b = range - j * step;

                    // è·³è¿‡åŸç‚¹é™„è¿‘
                    if (Math.abs(a) < 0.1 && Math.abs(b) < 0.1) continue;

                    const branches = complexCubeRoot(a, b);

                    const screenX = centerX + a * scale;
                    const screenY = centerY - b * scale;

                    let metricFactor = 1;
                    if (useMetric) {
                        metricFactor = riemannMetric(a, b);
                    }

                    // ç»˜åˆ¶é€‰å®šçš„åˆ†æ”¯
                    branchesToShow.forEach(branchIndex => {
                        const y = branches[branchIndex];
                        const arrowEndX = screenX + y.real * scale * arrowScaleFactor * metricFactor;
                        const arrowEndY = screenY - y.imag * scale * arrowScaleFactor * metricFactor;

                        const color = getBranchColor(branchIndex);
                        drawArrow(svg, screenX, screenY, arrowEndX, arrowEndY, color);
                    });

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', screenX);
                    circle.setAttribute('cy', screenY);
                    circle.setAttribute('r', '2');
                    circle.setAttribute('fill', '#333');
                    circle.setAttribute('opacity', '0.6');
                    svg.appendChild(circle);
                }
            }
        }

        function render2D() {
            svg1.innerHTML = '';

            drawGrid(svg1);
            drawReferenceCircles(svg1);
            drawAxes(svg1);
            drawVectorField(svg1, false);

            updateValues();
        }

        gridDensityInput.addEventListener('input', render2D);
        scaleInput.addEventListener('input', render2D);
        arrowScaleInput.addEventListener('input', render2D);
        showGridCheckbox.addEventListener('change', render2D);
        showAxesCheckbox.addEventListener('change', render2D);
        showCirclesCheckbox.addEventListener('change', render2D);

        // æ·»åŠ åˆ†æ”¯æ˜¾ç¤ºæ¨¡å¼çš„äº‹ä»¶ç›‘å¬
        document.querySelectorAll('input[name="displayMode2D"]').forEach(radio => {
            radio.addEventListener('change', render2D);
        });

        render2D();

        // ==================== 3D éƒ¨åˆ† ====================

        // 3D æ§åˆ¶å…ƒç´ 
        const vectorLengthInput = document.getElementById('vectorLength');
        const samplingRangeInput = document.getElementById('samplingRange');
        const showSphereCheckbox = document.getElementById('showSphere');
        const showWireframeCheckbox = document.getElementById('showWireframe');
        const showAxesHelperCheckbox = document.getElementById('showAxesHelper');

        function updateValues3D() {
            document.getElementById('vectorLengthValue').textContent = vectorLengthInput.value;
            document.getElementById('samplingRangeValue').textContent = samplingRangeInput.value;
        }

        // Three.js åœºæ™¯è®¾ç½®
        let scene, camera, renderer, controls;
        let sphereMesh, wireframeMesh, axesHelper;
        let vectorGroup;

        function initThreeJS() {
            const container = document.getElementById('threejs-canvas');

            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);

            // ç›¸æœº - ä» x=1 æ­£ä¸Šæ–¹ä¿¯è§†
            camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
            camera.position.set(3, 0, 0);
            camera.up.set(0, 0, 1);
            camera.lookAt(0, 0, 0);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(700, 700);
            container.appendChild(renderer.domElement);

            // æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // å…‰æº
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // çƒä½“
            const sphereGeometry = new THREE.SphereGeometry(1, 64, 64);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0xd0d0d0,
                transparent: false,
                side: THREE.DoubleSide,
                shininess: 30
            });
            sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
            scene.add(sphereMesh);

            // ç½‘æ ¼çº¿
            const wireframeGeometry = new THREE.SphereGeometry(1.001, 32, 32);
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x666666,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            wireframeMesh = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
            scene.add(wireframeMesh);

            // åæ ‡è½´
            axesHelper = new THREE.AxesHelper(1.5);
            scene.add(axesHelper);

            // å‘é‡ç»„
            vectorGroup = new THREE.Group();
            scene.add(vectorGroup);

            // æ·»åŠ ç‰¹æ®Šç‚¹æ ‡æ³¨
            addSpecialPoints();

            animate();
        }

        // åˆ›å»ºæ–‡å­—ç²¾çµæ ‡ç­¾
        function createTextSprite(text, color = '#000000') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;

            context.clearRect(0, 0, canvas.width, canvas.height);

            context.font = 'Bold 60px Arial';
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.5, 0.25, 1);

            return sprite;
        }

        // æ·»åŠ ç‰¹æ®Šç‚¹æ ‡æ³¨
        function addSpecialPoints() {
            const specialPoints = [
                { name: '0', x: 0, y: 0, color: '#ff0000' },
                { name: '1', x: 1, y: 0, color: '#0000ff' },
                { name: '-1', x: -1, y: 0, color: '#0000ff' },
                { name: 'i', x: 0, y: 1, color: '#00aa00' },
                { name: '-i', x: 0, y: -1, color: '#00aa00' },
                { name: 'âˆ', x: null, y: null, color: '#aa00aa' }
            ];

            specialPoints.forEach(point => {
                let pos;

                if (point.name === 'âˆ') {
                    pos = { x: 0, y: 0, z: 1 };
                } else {
                    pos = stereographicProjection(point.x, point.y);
                }

                const dotGeometry = new THREE.SphereGeometry(0.04, 16, 16);
                const dotMaterial = new THREE.MeshBasicMaterial({ color: point.color });
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.position.set(pos.x, pos.y, pos.z);
                scene.add(dot);

                const label = createTextSprite(point.name, point.color);
                const offset = 1.3;
                label.position.set(pos.x * offset, pos.y * offset, pos.z * offset);
                scene.add(label);
            });
        }

        // ç«‹ä½“æŠ•å½±ï¼šå¤å¹³é¢ -> çƒé¢
        function stereographicProjection(x, y) {
            const rSquared = x * x + y * y;
            const denom = 1 + rSquared;
            return {
                x: 2 * x / denom,
                y: 2 * y / denom,
                z: (rSquared - 1) / denom
            };
        }

        // é€†ç«‹ä½“æŠ•å½±ï¼šçƒé¢ -> å¤å¹³é¢
        function inverseStereographicProjection(X, Y, Z) {
            if (Math.abs(Z - 1) < 0.001) {
                return { x: 0, y: 0, isInfinity: true };
            }
            const denom = 1 - Z;
            return {
                x: X / denom,
                y: Y / denom,
                isInfinity: false
            };
        }

        // åˆ›å»ºç®­å¤´
        function createArrow(origin, direction, length, color) {
            const dir = new THREE.Vector3(direction.x, direction.y, direction.z).normalize();
            const arrow = new THREE.ArrowHelper(dir, origin, length, color, length * 0.2, length * 0.15);
            return arrow;
        }

        // ç»˜åˆ¶3Då‘é‡åœº
        function draw3DVectorField() {
            while (vectorGroup.children.length > 0) {
                vectorGroup.remove(vectorGroup.children[0]);
            }

            const sphereDensity = parseInt(samplingRangeInput.value);
            const vectorLen = parseFloat(vectorLengthInput.value) / 100;

            // è·å–æ˜¾ç¤ºæ¨¡å¼
            const displayMode = document.querySelector('input[name="displayMode3D"]:checked').value;
            let branchesToShow = [];

            if (displayMode === 'both') {
                branchesToShow = [0, 1, 2];
            } else if (displayMode === 'onlyBranch0') {
                branchesToShow = [0];
            } else if (displayMode === 'onlyBranch1') {
                branchesToShow = [1];
            } else if (displayMode === 'onlyBranch2') {
                branchesToShow = [2];
            }

            const thetaSteps = sphereDensity;
            const phiSteps = sphereDensity * 2;

            for (let i = 0; i <= thetaSteps; i++) {
                const theta = (Math.PI * i) / thetaSteps;

                for (let j = 0; j < phiSteps; j++) {
                    const phi = (2 * Math.PI * j) / phiSteps;

                    const X = Math.sin(theta) * Math.cos(phi);
                    const Y = Math.sin(theta) * Math.sin(phi);
                    const Z = Math.cos(theta);

                    const origin = new THREE.Vector3(X, Y, Z);

                    const complex = inverseStereographicProjection(X, Y, Z);
                    if (complex.isInfinity) continue;

                    const x = complex.x;
                    const y = complex.y;

                    // è·³è¿‡åŸç‚¹é™„è¿‘
                    if (Math.abs(x) < 0.1 && Math.abs(y) < 0.1) continue;

                    const branches = complexCubeRoot(x, y);

                    // çƒé¢åˆ‡ç©ºé—´çš„æ­£äº¤åŸº
                    const e_theta = new THREE.Vector3(
                        Math.cos(theta) * Math.cos(phi),
                        Math.cos(theta) * Math.sin(phi),
                        -Math.sin(theta)
                    );
                    const e_phi = new THREE.Vector3(
                        -Math.sin(theta) * Math.sin(phi),
                        Math.sin(theta) * Math.cos(phi),
                        0
                    );

                    // åº¦é‡ç¼©æ”¾å› å­å’Œçº¬åº¦è¡°å‡
                    const r = Math.sqrt(x * x + y * y);
                    const metricFactor = 2 / (1 + r * r);
                    const distanceFromEquator = Math.abs(theta - Math.PI / 2);
                    const latitudeDecay = Math.exp(-2 * distanceFromEquator);
                    const totalScale = metricFactor * latitudeDecay;

                    // ç»˜åˆ¶é€‰å®šçš„åˆ†æ”¯
                    branchesToShow.forEach(branchIndex => {
                        const result = branches[branchIndex];

                        let direction = e_phi.clone().multiplyScalar(result.real * totalScale)
                            .add(e_theta.clone().multiplyScalar(-result.imag * totalScale));

                        if (direction.length() > 0.0001) {
                            direction.normalize();
                            const colors = [0x2563eb, 0xdc2626, 0x16a34a];
                            const arrow = createArrow(origin, direction, vectorLen, colors[branchIndex]);
                            vectorGroup.add(arrow);
                        }
                    });
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function update3DVisibility() {
            sphereMesh.visible = showSphereCheckbox.checked;
            wireframeMesh.visible = showWireframeCheckbox.checked;
            axesHelper.visible = showAxesHelperCheckbox.checked;
        }

        function render3D() {
            draw3DVectorField();
            update3DVisibility();
            updateValues3D();
        }

        // 3D äº‹ä»¶ç›‘å¬
        samplingRangeInput.addEventListener('input', render3D);
        vectorLengthInput.addEventListener('input', render3D);
        showSphereCheckbox.addEventListener('change', update3DVisibility);
        showWireframeCheckbox.addEventListener('change', update3DVisibility);
        showAxesHelperCheckbox.addEventListener('change', update3DVisibility);

        // æ·»åŠ åˆ†æ”¯æ˜¾ç¤ºæ¨¡å¼çš„äº‹ä»¶ç›‘å¬
        document.querySelectorAll('input[name="displayMode3D"]').forEach(radio => {
            radio.addEventListener('change', render3D);
        });

        // åˆå§‹åŒ–3D
        initThreeJS();
        render3D();

        // ==================== é»æ›¼é¢æ„é€ éƒ¨åˆ† ====================

        const constructionCanvas = document.getElementById('construction-canvas');
        let constructionScene, constructionCamera, constructionRenderer, constructionControls;
        let sphere1Group, sphere2Group, sphere3Group;
        let vectorGroup1, vectorGroup2, vectorGroup3;
        let sphereMesh1, sphereMesh2, sphereMesh3, wireframeMesh1, wireframeMesh2, wireframeMesh3;
        let cutLine1, cutLine2, cutLine3;
        let cutGap1, cutGap2, cutGap3;
        let stitchLines;
        let finalSphereGroup;
        let currentStep = 0;
        const maxSteps = 4;

        const constructionSamplingInput = document.getElementById('constructionSampling');
        const constructionVectorLengthInput = document.getElementById('constructionVectorLength');
        const constructionShowSphereCheckbox = document.getElementById('constructionShowSphere');
        const constructionShowWireframeCheckbox = document.getElementById('constructionShowWireframe');

        function updateConstructionValues() {
            document.getElementById('constructionSamplingValue').textContent = constructionSamplingInput.value;
            document.getElementById('constructionVectorLengthValue').textContent = constructionVectorLengthInput.value;
        }

        function initConstructionScene() {
            const container = constructionCanvas;

            constructionScene = new THREE.Scene();
            constructionScene.background = new THREE.Color(0xf5f5f5);

            constructionCamera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
            constructionCamera.position.set(0, -6, 1);
            constructionCamera.up.set(0, 0, 1);
            constructionCamera.lookAt(0, 0, 0);

            constructionRenderer = new THREE.WebGLRenderer({ antialias: true });
            constructionRenderer.setSize(700, 700);
            container.appendChild(constructionRenderer.domElement);

            constructionControls = new THREE.OrbitControls(constructionCamera, constructionRenderer.domElement);
            constructionControls.enableDamping = true;
            constructionControls.dampingFactor = 0.05;
            constructionControls.minPolarAngle = 0;
            constructionControls.maxPolarAngle = Math.PI;
            constructionControls.enableRotate = true;
            constructionControls.rotateSpeed = 1.0;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            constructionScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(5, 5, 5);
            constructionScene.add(directionalLight);

            const axesHelper = new THREE.AxesHelper(2);
            constructionScene.add(axesHelper);

            // åˆ›å»ºä¸‰ä¸ªçƒä½“ç»„
            sphere1Group = new THREE.Group();
            sphere2Group = new THREE.Group();
            sphere3Group = new THREE.Group();
            constructionScene.add(sphere1Group);
            constructionScene.add(sphere2Group);
            constructionScene.add(sphere3Group);

            // åˆ›å»ºå‘é‡ç»„
            vectorGroup1 = new THREE.Group();
            vectorGroup2 = new THREE.Group();
            vectorGroup3 = new THREE.Group();
            sphere1Group.add(vectorGroup1);
            sphere2Group.add(vectorGroup2);
            sphere3Group.add(vectorGroup3);

            createSpheresWithVectorFields();
            animateConstruction();
        }

        function createSpheresWithVectorFields() {
            // æ¸…ç©º
            while (sphere1Group.children.length > 0) {
                sphere1Group.remove(sphere1Group.children[0]);
            }
            while (sphere2Group.children.length > 0) {
                sphere2Group.remove(sphere2Group.children[0]);
            }
            while (sphere3Group.children.length > 0) {
                sphere3Group.remove(sphere3Group.children[0]);
            }

            // é‡æ–°åˆ›å»ºå‘é‡ç»„
            vectorGroup1 = new THREE.Group();
            vectorGroup2 = new THREE.Group();
            vectorGroup3 = new THREE.Group();

            // åˆ›å»ºçƒä½“1ï¼ˆè“è‰²ï¼šâˆ›xï¼‰
            const sphereGeometry1 = new THREE.SphereGeometry(1, 64, 64);
            const sphereMaterial1 = new THREE.MeshPhongMaterial({
                color: 0xd0d0d0,
                transparent: false,
                side: THREE.DoubleSide,
                shininess: 30
            });
            sphereMesh1 = new THREE.Mesh(sphereGeometry1, sphereMaterial1);
            sphere1Group.add(sphereMesh1);

            const wireframeGeometry1 = new THREE.SphereGeometry(1.001, 32, 32);
            const wireframeMaterial1 = new THREE.MeshBasicMaterial({
                color: 0x666666,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            wireframeMesh1 = new THREE.Mesh(wireframeGeometry1, wireframeMaterial1);
            sphere1Group.add(wireframeMesh1);

            // åˆ›å»ºçƒä½“2ï¼ˆçº¢è‰²ï¼šÏ‰âˆ›xï¼‰
            const sphereGeometry2 = new THREE.SphereGeometry(1, 64, 64);
            const sphereMaterial2 = new THREE.MeshPhongMaterial({
                color: 0xd0d0d0,
                transparent: false,
                side: THREE.DoubleSide,
                shininess: 30
            });
            sphereMesh2 = new THREE.Mesh(sphereGeometry2, sphereMaterial2);
            sphere2Group.add(sphereMesh2);

            const wireframeGeometry2 = new THREE.SphereGeometry(1.001, 32, 32);
            const wireframeMaterial2 = new THREE.MeshBasicMaterial({
                color: 0x666666,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            wireframeMesh2 = new THREE.Mesh(wireframeGeometry2, wireframeMaterial2);
            sphere2Group.add(wireframeMesh2);

            // åˆ›å»ºçƒä½“3ï¼ˆç»¿è‰²ï¼šÏ‰Â²âˆ›xï¼‰
            const sphereGeometry3 = new THREE.SphereGeometry(1, 64, 64);
            const sphereMaterial3 = new THREE.MeshPhongMaterial({
                color: 0xd0d0d0,
                transparent: false,
                side: THREE.DoubleSide,
                shininess: 30
            });
            sphereMesh3 = new THREE.Mesh(sphereGeometry3, sphereMaterial3);
            sphere3Group.add(sphereMesh3);

            const wireframeGeometry3 = new THREE.SphereGeometry(1.001, 32, 32);
            const wireframeMaterial3 = new THREE.MeshBasicMaterial({
                color: 0x666666,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            wireframeMesh3 = new THREE.Mesh(wireframeGeometry3, wireframeMaterial3);
            sphere3Group.add(wireframeMesh3);

            sphere1Group.add(vectorGroup1);
            sphere2Group.add(vectorGroup2);
            sphere3Group.add(vectorGroup3);

            // æ·»åŠ åˆ†æ”¯æ ‡ç­¾
            const label1 = createTextSprite('âˆ›x', '#2563eb');
            label1.position.set(0, 0, 1.5);
            sphere1Group.add(label1);

            const label2 = createTextSprite('Ï‰âˆ›x', '#dc2626');
            label2.position.set(0, 0, 1.5);
            sphere2Group.add(label2);

            const label3 = createTextSprite('Ï‰Â²âˆ›x', '#16a34a');
            label3.position.set(0, 0, 1.5);
            sphere3Group.add(label3);

            // æ·»åŠ ç‰¹æ®Šç‚¹æ ‡æ³¨ï¼ˆä¸‰ä¸ªçƒå…±äº«ï¼‰
            addSpecialPointsToSphere(sphere1Group);
            addSpecialPointsToSphere(sphere2Group);
            addSpecialPointsToSphere(sphere3Group);

            // åˆ›å»ºåˆ‡å‰²çº¿ï¼ˆçº¢è‰²ï¼Œåˆå§‹éšè—ï¼‰
            cutLine1 = createCutLine(0xff0000);
            cutLine2 = createCutLine(0xff0000);
            cutLine3 = createCutLine(0xff0000);
            cutLine1.visible = false;
            cutLine2.visible = false;
            cutLine3.visible = false;
            sphere1Group.add(cutLine1);
            sphere2Group.add(cutLine2);
            sphere3Group.add(cutLine3);

            // åˆ›å»ºåˆ‡å£ï¼ˆç™½è‰²å®½çº¿ï¼Œåˆå§‹éšè—ï¼‰
            cutGap1 = createCutGap();
            cutGap2 = createCutGap();
            cutGap3 = createCutGap();
            cutGap1.visible = false;
            cutGap2.visible = false;
            cutGap3.visible = false;
            sphere1Group.add(cutGap1);
            sphere2Group.add(cutGap2);
            sphere3Group.add(cutGap3);

            // åˆ›å»ºç¼åˆçº¿ï¼ˆåˆå§‹éšè—ï¼‰
            stitchLines = new THREE.Group();
            stitchLines.visible = false;
            constructionScene.add(stitchLines);

            // åˆ›å»ºæœ€ç»ˆé»æ›¼é¢çƒï¼ˆåˆå§‹éšè—ï¼‰
            finalSphereGroup = new THREE.Group();
            finalSphereGroup.visible = false;
            constructionScene.add(finalSphereGroup);
            createFinalRiemannSphere();

            // ç»˜åˆ¶å‘é‡åœº
            drawConstructionVectorFields();
            updateConstructionStep();
        }

        function addSpecialPointsToSphere(sphereGroup) {
            const specialPoints = [
                { name: '0', x: 0, y: 0, color: '#ff0000', size: 0.03 },
                { name: '1', x: 1, y: 0, color: '#0000ff', size: 0.03 },
                { name: '-1', x: -1, y: 0, color: '#0000ff', size: 0.03 },
                { name: 'i', x: 0, y: 1, color: '#00aa00', size: 0.03 },
                { name: '-i', x: 0, y: -1, color: '#00aa00', size: 0.03 },
                { name: 'âˆ', x: null, y: null, color: '#aa00aa', size: 0.03 }
            ];

            specialPoints.forEach(point => {
                let pos;
                if (point.name === 'âˆ') {
                    pos = { x: 0, y: 0, z: 1 };
                } else {
                    pos = stereographicProjection(point.x, point.y);
                }

                const dotGeometry = new THREE.SphereGeometry(point.size, 16, 16);
                const dotMaterial = new THREE.MeshBasicMaterial({ color: point.color });
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.position.set(pos.x, pos.y, pos.z);
                sphereGroup.add(dot);
            });
        }

        function createCutLine(color) {
            const points = [];
            const numPoints = 50;

            // ä»0åˆ°-âˆæ²¿è´Ÿå®è½´ï¼Œå¯¹åº”çƒé¢ä¸Šä»å—æåˆ°èµ¤é“å·¦ä¾§
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const x = -t * 5; // è´Ÿå®è½´
                const y = 0;

                if (t === 0) {
                    points.push(new THREE.Vector3(0, 0, -1)); // å—æ
                } else {
                    const pos = stereographicProjection(x, y);
                    points.push(new THREE.Vector3(pos.x, pos.y, pos.z));
                }
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: color, linewidth: 2 });
            const line = new THREE.Line(geometry, material);
            return line;
        }

        function createCutGap() {
            const points = [];
            const numPoints = 50;

            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const x = -t * 5;
                const y = 0;

                if (t === 0) {
                    points.push(new THREE.Vector3(0, 0, -1));
                } else {
                    const pos = stereographicProjection(x, y);
                    points.push(new THREE.Vector3(pos.x, pos.y, pos.z));
                }
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 8 });
            const line = new THREE.Line(geometry, material);
            return line;
        }

        function createFinalRiemannSphere() {
            while (finalSphereGroup.children.length > 0) {
                finalSphereGroup.remove(finalSphereGroup.children[0]);
            }

            const sphereGeometry = new THREE.SphereGeometry(1, 64, 64);
            const sphereMaterial = new THREE.MeshPhongMaterial({
                color: 0xd0d0d0,
                transparent: false,
                side: THREE.DoubleSide,
                shininess: 30
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            finalSphereGroup.add(sphere);

            const wireframeGeometry = new THREE.SphereGeometry(1.001, 32, 32);
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x666666,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
            finalSphereGroup.add(wireframe);

            // æ·»åŠ å‘é‡åœº
            const finalVectorGroup = new THREE.Group();
            finalSphereGroup.add(finalVectorGroup);
            drawFinalVectorField(finalVectorGroup);

            addSpecialPointsToSphere(finalSphereGroup);
        }

        function drawFinalVectorField(vectorGroup) {
            const sphereDensity = parseInt(constructionSamplingInput.value);
            const vectorLen = parseFloat(constructionVectorLengthInput.value) / 100;

            const thetaSteps = sphereDensity;
            const phiSteps = sphereDensity * 2;

            for (let i = 0; i <= thetaSteps; i++) {
                const theta = (Math.PI * i) / thetaSteps;

                // è·³è¿‡æç‚¹é™„è¿‘
                if (theta < 0.01 || theta > Math.PI - 0.01) continue;

                for (let j = 0; j < phiSteps; j++) {
                    const phi = (2 * Math.PI * j) / phiSteps; // phi ä» 0 åˆ° 2Ï€

                    const X = Math.sin(theta) * Math.cos(phi);
                    const Y = Math.sin(theta) * Math.sin(phi);
                    const Z = Math.cos(theta);

                    const origin = new THREE.Vector3(X, Y, Z);

                    // åå‘ç«‹ä½“æŠ•å½±ï¼ˆåŒ—ææŠ•å½±ï¼‰
                    const r = Math.cos(theta / 2) / Math.sin(theta / 2); // cot(theta/2)

                    // æ ¹æ® phi çš„èŒƒå›´å†³å®šç”¨å“ªä¸ªåˆ†æ”¯å’Œå¯¹åº”çš„ arg(x)
                    // åˆ†æ”¯åˆ‡å‰²çº¿åœ¨ phi = Ï€/3, Ï€, 5Ï€/3ï¼ˆå¯¹åº”è´Ÿå®è½´ -1, -1', -1''ï¼‰
                    let branchIndex;
                    let argX;

                    if (phi < Math.PI/3) {
                        // åˆ†æ”¯0ï¼ˆè“è‰²ï¼‰ï¼šphi âˆˆ [0, Ï€/3)
                        branchIndex = 0;
                        argX = 3 * phi;  // argX âˆˆ [0, Ï€)
                    } else if (phi < Math.PI) {
                        // åˆ†æ”¯1ï¼ˆçº¢è‰²ï¼‰ï¼šphi âˆˆ [Ï€/3, Ï€)
                        branchIndex = 1;
                        argX = 3 * phi - 2*Math.PI;  // argX âˆˆ [-Ï€, Ï€)
                    } else if (phi < 5*Math.PI/3) {
                        // åˆ†æ”¯2ï¼ˆç»¿è‰²ï¼‰ï¼šphi âˆˆ [Ï€, 5Ï€/3)
                        branchIndex = 2;
                        argX = 3 * phi - 4*Math.PI;  // argX âˆˆ [-Ï€, Ï€)
                    } else {
                        // å›åˆ°åˆ†æ”¯0ï¼šphi âˆˆ [5Ï€/3, 2Ï€)
                        branchIndex = 0;
                        argX = 3 * phi - 6*Math.PI;  // argX âˆˆ [-Ï€, 0)
                    }

                    const x = r * Math.cos(argX);
                    const y = r * Math.sin(argX);

                    // è®¡ç®— âˆ›x
                    const ySolutions = complexCubeRoot(x, y);
                    const result = ySolutions[branchIndex];

                    // çƒé¢åˆ‡ç©ºé—´çš„æ­£äº¤åŸº
                    const e_theta = new THREE.Vector3(
                        Math.cos(theta) * Math.cos(phi),
                        Math.cos(theta) * Math.sin(phi),
                        -Math.sin(theta)
                    );
                    const e_phi = new THREE.Vector3(
                        -Math.sin(theta) * Math.sin(phi),
                        Math.sin(theta) * Math.cos(phi),
                        0
                    );

                    // åº¦é‡ç¼©æ”¾å› å­å’Œçº¬åº¦è¡°å‡
                    const metricFactor = 2 / (1 + r * r);
                    const distanceFromEquator = Math.abs(theta - Math.PI / 2);
                    const latitudeDecay = Math.exp(-2 * distanceFromEquator);
                    const totalScale = metricFactor * latitudeDecay;

                    let direction = e_phi.clone().multiplyScalar(result.real * totalScale)
                        .add(e_theta.clone().multiplyScalar(-result.imag * totalScale));

                    const colors = [0x2563eb, 0xdc2626, 0x16a34a];
                    const arrowColor = colors[branchIndex];

                    if (direction.length() > 0.0001) {
                        direction.normalize();
                        const arrow = createArrow(origin, direction, vectorLen, arrowColor);
                        vectorGroup.add(arrow);
                    } else {
                        const dot = new THREE.Mesh(
                            new THREE.SphereGeometry(0.02, 8, 8),
                            new THREE.MeshBasicMaterial({ color: arrowColor })
                        );
                        dot.position.copy(origin);
                        vectorGroup.add(dot);
                    }
                }
            }

            // æ·»åŠ èµ¤é“æ ‡æ³¨
            addEquatorLabels();

            // æ·»åŠ ç¼åˆçº¿æ˜¾ç¤º
            addFinalStitchLines();
        }

        function addFinalStitchLines() {
            // åœ¨æœ€ç»ˆé»æ›¼é¢ä¸Šæ˜¾ç¤ºä¸‰æ¡åˆ†æ”¯åˆ‡å‰²çº¿
            // åˆ†æ”¯åˆ‡å‰²çº¿ä½äºè´Ÿå®è½´æ–¹å‘ï¼Œå¯¹åº” argX = Ï€, 3Ï€, 5Ï€
            // ç”±äº argX = 3*phiï¼Œæ‰€ä»¥ phi = Ï€/3, Ï€, 5Ï€/3

            const numPoints = 60;
            const colors = [0x9333ea, 0xf59e0b, 0x06b6d4]; // ç´«ã€æ©™ã€é’

            // ä¸‰æ¡åˆ†æ”¯åˆ‡å‰²çº¿çš„ phi å€¼ï¼ˆå¯¹åº”èµ¤é“ä¸Šçš„ -1, -1', -1''ï¼‰
            const cutPhiValues = [Math.PI/3, Math.PI, 5*Math.PI/3];

            cutPhiValues.forEach((phi, idx) => {
                const points = [];

                // ä»å—æ(0)åˆ°åŒ—æ(âˆ)æ²¿ç€ç‰¹å®šçš„ phi å€¼ï¼ˆç»çº¿ï¼‰
                for (let i = 0; i <= numPoints; i++) {
                    const t = i / numPoints;
                    const theta = t * Math.PI; // ä»0(åŒ—æ)åˆ°Ï€(å—æ)

                    const X = Math.sin(theta) * Math.cos(phi);
                    const Y = Math.sin(theta) * Math.sin(phi);
                    const Z = Math.cos(theta);

                    points.push(new THREE.Vector3(X, Y, Z));
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: colors[idx],
                    linewidth: 4,
                    transparent: true,
                    opacity: 0.8
                });
                const line = new THREE.Line(geometry, material);
                finalSphereGroup.add(line);
            });
        }

        function addEquatorLabels() {
            // èµ¤é“ç»•ä¸‰åœˆï¼Œ12ä¸ªç‚¹å‡åŒ€åˆ†å¸ƒ
            // phi å’Œå¤æ•°è§’åº¦çš„å…³ç³»ï¼šcomplexArg = phi/3
            // ç¬¬ä¸€åœˆï¼ˆphi: 0â†’2Ï€/3ï¼‰åŒ…å« 1,i,-1,-iï¼ˆç¬¬ä¸€ä¸ªåˆ†æ”¯ï¼‰
            // ç¬¬äºŒåœˆï¼ˆphi: 2Ï€/3â†’4Ï€/3ï¼‰åŒ…å« 1',i',-1',-i'ï¼ˆç¬¬äºŒä¸ªåˆ†æ”¯ï¼‰
            // ç¬¬ä¸‰åœˆï¼ˆphi: 4Ï€/3â†’2Ï€ï¼‰åŒ…å« 1'',i'',-1'',-i''ï¼ˆç¬¬ä¸‰ä¸ªåˆ†æ”¯ï¼‰
            const labels = [
                // ç¬¬ä¸€åœˆ
                { phi: 0, name: '1', color: '#0000ff' },
                { phi: Math.PI/6, name: 'i', color: '#00aa00' },
                { phi: Math.PI/3, name: '-1', color: '#0000ff' },
                { phi: Math.PI/2, name: '-i', color: '#00aa00' },
                // ç¬¬äºŒåœˆ
                { phi: 2*Math.PI/3, name: "1'", color: '#0000ff' },
                { phi: 5*Math.PI/6, name: "i'", color: '#00aa00' },
                { phi: Math.PI, name: "-1'", color: '#0000ff' },
                { phi: 7*Math.PI/6, name: "-i'", color: '#00aa00' },
                // ç¬¬ä¸‰åœˆ
                { phi: 4*Math.PI/3, name: "1''", color: '#0000ff' },
                { phi: 3*Math.PI/2, name: "i''", color: '#00aa00' },
                { phi: 5*Math.PI/3, name: "-1''", color: '#0000ff' },
                { phi: 11*Math.PI/6, name: "-i''", color: '#00aa00' }
            ];

            const theta = Math.PI / 2; // èµ¤é“

            labels.forEach(item => {
                const X = Math.sin(theta) * Math.cos(item.phi);
                const Y = Math.sin(theta) * Math.sin(item.phi);
                const Z = Math.cos(theta);

                const dotGeometry = new THREE.SphereGeometry(0.04, 16, 16);
                const dotMaterial = new THREE.MeshBasicMaterial({ color: item.color });
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.position.set(X, Y, Z);
                finalSphereGroup.add(dot);

                const label = createTextSprite(item.name, item.color);
                const offset = 1.3;
                label.position.set(X * offset, Y * offset, Z * offset);
                finalSphereGroup.add(label);
            });

            // æ·»åŠ  0 (å—æ) å’Œ âˆ (åŒ—æ) æ ‡æ³¨
            const southPole = { x: 0, y: 0, z: -1, name: '0', color: '#ff0000' };
            const northPole = { x: 0, y: 0, z: 1, name: 'âˆ', color: '#aa00aa' };

            [southPole, northPole].forEach(point => {
                const dotGeometry = new THREE.SphereGeometry(0.04, 16, 16);
                const dotMaterial = new THREE.MeshBasicMaterial({ color: point.color });
                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                dot.position.set(point.x, point.y, point.z);
                finalSphereGroup.add(dot);

                const label = createTextSprite(point.name, point.color);
                const offset = 1.4;
                label.position.set(point.x * offset, point.y * offset, point.z * offset);
                finalSphereGroup.add(label);
            });
        }

        function drawConstructionVectorFields() {
            // æ¸…é™¤æ—§å‘é‡
            while (vectorGroup1.children.length > 0) {
                vectorGroup1.remove(vectorGroup1.children[0]);
            }
            while (vectorGroup2.children.length > 0) {
                vectorGroup2.remove(vectorGroup2.children[0]);
            }
            while (vectorGroup3.children.length > 0) {
                vectorGroup3.remove(vectorGroup3.children[0]);
            }

            const sphereDensity = parseInt(constructionSamplingInput.value);
            const vectorLen = parseFloat(constructionVectorLengthInput.value) / 100;

            const thetaSteps = sphereDensity;
            const phiSteps = sphereDensity * 2;

            for (let i = 0; i <= thetaSteps; i++) {
                const theta = (Math.PI * i) / thetaSteps;

                for (let j = 0; j < phiSteps; j++) {
                    const phi = (2 * Math.PI * j) / phiSteps;

                    const X = Math.sin(theta) * Math.cos(phi);
                    const Y = Math.sin(theta) * Math.sin(phi);
                    const Z = Math.cos(theta);

                    const origin = new THREE.Vector3(X, Y, Z);
                    const complex = inverseStereographicProjection(X, Y, Z);
                    if (complex.isInfinity) continue;

                    const x = complex.x;
                    const y = complex.y;

                    if (Math.abs(x) < 0.1 && Math.abs(y) < 0.1) continue;

                    const branches = complexCubeRoot(x, y);

                    const e_theta = new THREE.Vector3(
                        Math.cos(theta) * Math.cos(phi),
                        Math.cos(theta) * Math.sin(phi),
                        -Math.sin(theta)
                    );
                    const e_phi = new THREE.Vector3(
                        -Math.sin(theta) * Math.sin(phi),
                        Math.sin(theta) * Math.cos(phi),
                        0
                    );

                    const r = Math.sqrt(x * x + y * y);
                    const metricFactor = 2 / (1 + r * r);
                    const distanceFromEquator = Math.abs(theta - Math.PI / 2);
                    const latitudeDecay = Math.exp(-2 * distanceFromEquator);
                    const totalScale = metricFactor * latitudeDecay;

                    // åˆ†æ”¯0ï¼ˆè“è‰²ï¼‰
                    let result0 = branches[0];
                    let direction0 = e_phi.clone().multiplyScalar(result0.real * totalScale)
                        .add(e_theta.clone().multiplyScalar(-result0.imag * totalScale));
                    if (direction0.length() > 0.0001) {
                        direction0.normalize();
                        const arrow0 = createArrow(origin, direction0, vectorLen, 0x2563eb);
                        vectorGroup1.add(arrow0);
                    }

                    // åˆ†æ”¯1ï¼ˆçº¢è‰²ï¼‰
                    let result1 = branches[1];
                    let direction1 = e_phi.clone().multiplyScalar(result1.real * totalScale)
                        .add(e_theta.clone().multiplyScalar(-result1.imag * totalScale));
                    if (direction1.length() > 0.0001) {
                        direction1.normalize();
                        const arrow1 = createArrow(origin, direction1, vectorLen, 0xdc2626);
                        vectorGroup2.add(arrow1);
                    }

                    // åˆ†æ”¯2ï¼ˆç»¿è‰²ï¼‰
                    let result2 = branches[2];
                    let direction2 = e_phi.clone().multiplyScalar(result2.real * totalScale)
                        .add(e_theta.clone().multiplyScalar(-result2.imag * totalScale));
                    if (direction2.length() > 0.0001) {
                        direction2.normalize();
                        const arrow2 = createArrow(origin, direction2, vectorLen, 0x16a34a);
                        vectorGroup3.add(arrow2);
                    }
                }
            }
        }

        function createStitchLines() {
            while (stitchLines.children.length > 0) {
                stitchLines.remove(stitchLines.children[0]);
            }

            const numMeridians = 25; // ç»çº¿æ•°é‡
            const numPoints = 60; // æ¯æ¡ç»çº¿ä¸Šçš„ç‚¹æ•°
            const maxOffset = 0.15; // åˆ‡å£å®½åº¦çš„ä¸€åŠ

            // è·å–çƒä½“ä½ç½®å’Œæ—‹è½¬
            const pos1 = sphere1Group.position;
            const pos2 = sphere2Group.position;
            const pos3 = sphere3Group.position;
            const rot1 = sphere1Group.rotation;
            const rot2 = sphere2Group.rotation;
            const rot3 = sphere3Group.rotation;

            // å¯¹æ¯ä¸ªçƒï¼Œè®¡ç®—åˆ‡å£æŸä¸€è¾¹ç¼˜ä¸Šçš„ç»çº¿
            function getCutEdgeMeridians(position, rotation, isRightEdge) {
                const meridians = [];

                for (let m = 0; m < numMeridians; m++) {
                    const points = [];

                    for (let i = 0; i <= numPoints; i++) {
                        const t = i / numPoints;

                        let x, y, z, widthFactor;
                        if (t === 0) {
                            // å—æç‚¹
                            x = 0; y = 0; z = -1;
                            widthFactor = 0;
                        } else if (t === 1) {
                            // åŒ—æç‚¹
                            x = 0; y = 0; z = 1;
                            widthFactor = 0;
                        } else {
                            // æ²¿è´Ÿå®è½´ï¼Œä½¿ç”¨å¯¹æ•°åˆ†å¸ƒ
                            const complexX = -Math.pow(10, (t - 0.5) * 4);
                            const complexY = 0;
                            const pos = stereographicProjection(complexX, complexY);
                            x = pos.x; y = pos.y; z = pos.z;
                            // ä¸­é—´å®½ï¼Œä¸¤ç«¯çª„
                            widthFactor = Math.sin(t * Math.PI);
                        }

                        // æ ¹æ®ç»çº¿ç¼–å·è®¡ç®—åç§»é‡
                        const offset = maxOffset * widthFactor * (m / (numMeridians - 1));
                        const point = new THREE.Vector3(x, y, z);
                        const tangent = new THREE.Vector3(-y, x, 0).normalize();

                        // å³è¾¹ç¼˜æˆ–å·¦è¾¹ç¼˜
                        const edgePoint = point.clone().add(
                            tangent.clone().multiplyScalar(isRightEdge ? offset : -offset)
                        );

                        edgePoint.normalize();
                        edgePoint.applyEuler(rotation);
                        edgePoint.add(position);

                        points.push(edgePoint);
                    }

                    meridians.push(points);
                }

                return meridians;
            }

            // è®¡ç®—æ¯ä¸ªçƒçš„å·¦å³è¾¹ç¼˜ç»çº¿
            const meridians1Right = getCutEdgeMeridians(pos1, rot1, true);
            const meridians1Left = getCutEdgeMeridians(pos1, rot1, false);
            const meridians2Right = getCutEdgeMeridians(pos2, rot2, true);
            const meridians2Left = getCutEdgeMeridians(pos2, rot2, false);
            const meridians3Right = getCutEdgeMeridians(pos3, rot3, true);
            const meridians3Left = getCutEdgeMeridians(pos3, rot3, false);

            // ç»˜åˆ¶ç¼åˆçš„æ›²é¢ï¼ˆç”¨ç»çº¿è¿æ¥ï¼‰
            // 1å³ -> 2å·¦ (ç´«è‰²)
            for (let m = 0; m < numMeridians; m++) {
                for (let i = 0; i < numPoints; i++) {
                    const p1 = meridians1Right[m][i];
                    const p2 = meridians1Right[m][i + 1];
                    const p3 = meridians2Left[m][i];
                    const p4 = meridians2Left[m][i + 1];

                    const geom = new THREE.BufferGeometry().setFromPoints([p1, p3, p4, p2, p1]);
                    const line = new THREE.Line(geom, new THREE.LineBasicMaterial({
                        color: 0x9333ea,
                        linewidth: 1,
                        transparent: true,
                        opacity: 0.4
                    }));
                    stitchLines.add(line);
                }
            }

            // 2å³ -> 3å·¦ (æ©™è‰²)
            for (let m = 0; m < numMeridians; m++) {
                for (let i = 0; i < numPoints; i++) {
                    const p1 = meridians2Right[m][i];
                    const p2 = meridians2Right[m][i + 1];
                    const p3 = meridians3Left[m][i];
                    const p4 = meridians3Left[m][i + 1];

                    const geom = new THREE.BufferGeometry().setFromPoints([p1, p3, p4, p2, p1]);
                    const line = new THREE.Line(geom, new THREE.LineBasicMaterial({
                        color: 0xf59e0b,
                        linewidth: 1,
                        transparent: true,
                        opacity: 0.4
                    }));
                    stitchLines.add(line);
                }
            }

            // 3å³ -> 1å·¦ (é’è‰²)
            for (let m = 0; m < numMeridians; m++) {
                for (let i = 0; i < numPoints; i++) {
                    const p1 = meridians3Right[m][i];
                    const p2 = meridians3Right[m][i + 1];
                    const p3 = meridians1Left[m][i];
                    const p4 = meridians1Left[m][i + 1];

                    const geom = new THREE.BufferGeometry().setFromPoints([p1, p3, p4, p2, p1]);
                    const line = new THREE.Line(geom, new THREE.LineBasicMaterial({
                        color: 0x06b6d4,
                        linewidth: 1,
                        transparent: true,
                        opacity: 0.4
                    }));
                    stitchLines.add(line);
                }
            }
        }

        function updateConstructionStep() {
            const stepLabel = document.getElementById('stepLabel');

            if (currentStep === 0) {
                // æ­¥éª¤1ï¼šä¸‰ä¸ªç‹¬ç«‹çš„çƒ
                sphere1Group.position.set(-2.5, 0, 0);
                sphere2Group.position.set(0, 0, 0);
                sphere3Group.position.set(2.5, 0, 0);
                sphere1Group.rotation.set(0, 0, 0);
                sphere2Group.rotation.set(0, 0, 0);
                sphere3Group.rotation.set(0, 0, 0);
                sphere1Group.visible = true;
                sphere2Group.visible = true;
                sphere3Group.visible = true;
                cutLine1.visible = false;
                cutLine2.visible = false;
                cutLine3.visible = false;
                cutGap1.visible = false;
                cutGap2.visible = false;
                cutGap3.visible = false;
                stitchLines.visible = false;
                finalSphereGroup.visible = false;
                stepLabel.textContent = 'æ­¥éª¤ 1/5ï¼šä¸‰ä¸ªç‹¬ç«‹çš„é»æ›¼çƒï¼Œåˆ†åˆ«æ˜¾ç¤º âˆ›xã€Ï‰âˆ›xã€Ï‰Â²âˆ›x çš„å‘é‡åœº';
            } else if (currentStep === 1) {
                // æ­¥éª¤2ï¼šæ ‡è®°åˆ‡å‰²çº¿
                sphere1Group.position.set(-2.5, 0, 0);
                sphere2Group.position.set(0, 0, 0);
                sphere3Group.position.set(2.5, 0, 0);
                sphere1Group.rotation.set(0, 0, 0);
                sphere2Group.rotation.set(0, 0, 0);
                sphere3Group.rotation.set(0, 0, 0);
                sphere1Group.visible = true;
                sphere2Group.visible = true;
                sphere3Group.visible = true;
                cutLine1.visible = true;
                cutLine2.visible = true;
                cutLine3.visible = true;
                cutGap1.visible = false;
                cutGap2.visible = false;
                cutGap3.visible = false;
                stitchLines.visible = false;
                finalSphereGroup.visible = false;
                stepLabel.textContent = 'æ­¥éª¤ 2/5ï¼šæ ‡è®°åˆ†æ”¯åˆ‡å‰²çº¿ï¼ˆçº¢çº¿ï¼‰ï¼šä»0åˆ°-âˆçš„è´Ÿå®è½´';
            } else if (currentStep === 2) {
                // æ­¥éª¤3ï¼šä¸‰è§’å½¢æ’åˆ—ï¼Œåˆ‡å£æœå†…
                const radius = 2.2;
                sphere1Group.position.set(0, -radius, 0);
                sphere2Group.position.set(radius * Math.cos(Math.PI/6), radius * Math.sin(Math.PI/6), 0);
                sphere3Group.position.set(-radius * Math.cos(Math.PI/6), radius * Math.sin(Math.PI/6), 0);
                // æ—‹è½¬ä½¿åˆ‡å£ï¼ˆè´Ÿå®è½´phi=Ï€ï¼‰æœå‘ä¸­å¿ƒ
                // çƒ1åœ¨-Yæ–¹å‘(è§’åº¦-Ï€/2)ï¼Œéœ€è¦æ—‹è½¬-Ï€/2è®©åˆ‡å£æœå†…
                sphere1Group.rotation.set(0, 0, -Math.PI/2);
                // çƒ2åœ¨è§’åº¦Ï€/6æ–¹å‘ï¼Œéœ€è¦æ—‹è½¬Ï€/6è®©åˆ‡å£æœå†…
                sphere2Group.rotation.set(0, 0, Math.PI/6);
                // çƒ3åœ¨è§’åº¦5Ï€/6æ–¹å‘ï¼Œéœ€è¦æ—‹è½¬5Ï€/6è®©åˆ‡å£æœå†…
                sphere3Group.rotation.set(0, 0, 5*Math.PI/6);
                sphere1Group.visible = true;
                sphere2Group.visible = true;
                sphere3Group.visible = true;
                cutLine1.visible = true;
                cutLine2.visible = true;
                cutLine3.visible = true;
                cutGap1.visible = true;
                cutGap2.visible = true;
                cutGap3.visible = true;
                stitchLines.visible = false;
                finalSphereGroup.visible = false;
                stepLabel.textContent = 'æ­¥éª¤ 3/5ï¼šä¸‰è§’å½¢æ’åˆ—ï¼Œæ²¿åˆ‡å‰²çº¿åˆ‡å¼€ï¼ˆç™½è‰²åˆ‡å£æœå‘ä¸­å¿ƒï¼‰';
            } else if (currentStep === 3) {
                // æ­¥éª¤4ï¼šå‡†å¤‡ç¼åˆ
                const radius = 2.2;
                sphere1Group.position.set(0, -radius, 0);
                sphere2Group.position.set(radius * Math.cos(Math.PI/6), radius * Math.sin(Math.PI/6), 0);
                sphere3Group.position.set(-radius * Math.cos(Math.PI/6), radius * Math.sin(Math.PI/6), 0);
                sphere1Group.rotation.set(0, 0, -Math.PI/2);
                sphere2Group.rotation.set(0, 0, Math.PI/6);
                sphere3Group.rotation.set(0, 0, 5*Math.PI/6);
                sphere1Group.visible = true;
                sphere2Group.visible = true;
                sphere3Group.visible = true;
                cutLine1.visible = false;
                cutLine2.visible = false;
                cutLine3.visible = false;
                cutGap1.visible = true;
                cutGap2.visible = true;
                cutGap3.visible = true;
                createStitchLines();
                stitchLines.visible = true;
                finalSphereGroup.visible = false;
                stepLabel.textContent = 'æ­¥éª¤ 4/5ï¼šå¾ªç¯ç¼åˆï¼ˆç´«çº¿ï¼š1â†’2ï¼Œæ©™çº¿ï¼š2â†’3ï¼Œé’çº¿ï¼š3â†’1ï¼‰';
            } else if (currentStep === 4) {
                // æ­¥éª¤5ï¼šæœ€ç»ˆé»æ›¼é¢
                sphere1Group.visible = false;
                sphere2Group.visible = false;
                sphere3Group.visible = false;
                stitchLines.visible = false;
                finalSphereGroup.visible = true;
                finalSphereGroup.position.set(0, 0, 0);
                stepLabel.textContent = 'æ­¥éª¤ 5/5ï¼šç¼åˆå®Œæˆï¼Œå½¢æˆæœ€ç»ˆé»æ›¼é¢ï¼ˆä¸‰æ¡åˆ†æ”¯åˆ‡å‰²çº¿åœ¨ -1, -1\', -1\'\' ä½ç½®ï¼Œå¯¹åº”ä¸‰ä¸ªsheetçš„ç¼åˆç‚¹ï¼‰';
            }

            updateConstructionVisibility();
        }

        function updateConstructionVisibility() {
            if (sphereMesh1) sphereMesh1.visible = constructionShowSphereCheckbox.checked;
            if (sphereMesh2) sphereMesh2.visible = constructionShowSphereCheckbox.checked;
            if (sphereMesh3) sphereMesh3.visible = constructionShowSphereCheckbox.checked;
            if (wireframeMesh1) wireframeMesh1.visible = constructionShowWireframeCheckbox.checked;
            if (wireframeMesh2) wireframeMesh2.visible = constructionShowWireframeCheckbox.checked;
            if (wireframeMesh3) wireframeMesh3.visible = constructionShowWireframeCheckbox.checked;

            if (finalSphereGroup.visible && finalSphereGroup.children.length > 0) {
                finalSphereGroup.children[0].visible = constructionShowSphereCheckbox.checked;
                if (finalSphereGroup.children.length > 1) {
                    finalSphereGroup.children[1].visible = constructionShowWireframeCheckbox.checked;
                }
            }
        }

        function renderConstruction() {
            drawConstructionVectorFields();
            if (finalSphereGroup.visible) {
                createFinalRiemannSphere();
            }
            updateConstructionValues();
        }

        function animateConstruction() {
            requestAnimationFrame(animateConstruction);
            constructionControls.update();
            constructionRenderer.render(constructionScene, constructionCamera);
        }

        // æ„é€ åœºæ™¯äº‹ä»¶ç›‘å¬
        document.getElementById('prevStep').addEventListener('click', () => {
            if (currentStep > 0) {
                currentStep--;
                updateConstructionStep();
            }
        });

        document.getElementById('nextStep').addEventListener('click', () => {
            if (currentStep < maxSteps) {
                currentStep++;
                updateConstructionStep();
            }
        });

        constructionSamplingInput.addEventListener('input', renderConstruction);
        constructionVectorLengthInput.addEventListener('input', renderConstruction);
        constructionShowSphereCheckbox.addEventListener('change', updateConstructionVisibility);
        constructionShowWireframeCheckbox.addEventListener('change', updateConstructionVisibility);

        // åˆå§‹åŒ–æ„é€ åœºæ™¯
        initConstructionScene();
    </script>
</body>
</html>
